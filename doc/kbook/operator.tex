\chapter{文字列 String}文字は、人類史上の「文字」の発明以来、最も重要な情報表現の要素である。情報社会といわれる現在においても、社会や文化を支える主要な情報は、文字によって記録され伝えられている。そのため、プログラミングにおける文字の重要性も明らかである。文字やテキストをうまく扱うことは、情報処理の正に中心的な役割を占めるからである。プログラミング言語では、文字を１文字、1文字扱うのは不便なので、複数個以上の文字の並びを「文字列 (string)」として扱う。Konohaは、文字列を表現するため、{\sf String}クラスを提供し、快適な文字列操作を提供してくれる。\section{文字列リテラル}文字列は、0個以上のUnicode 文字からなる。プログラミング言語では、識別子と文字列を区別するため、文字リテラルを用いて、文字列を与える。Konoha は、C/C++、Python、C\#に由来する3種類の文字列リテラル、さらに独自のリテラルもサポートしている。ここでは、これらを順番に説明する。\subsection{ダブルクオート}最も基本的な文字列リテラルは、文字列をダブルクオート(")で囲む形式である。\begin{quote}\begin{jverbatim}""                        // 空文字列"hello, world""3.14""Say \"hi.\""\end{jverbatim}\end{quote}文字列リテラル中で、表現できない文字列は、エスケープシーケンスを用いて表す。Konoha は、次の6種類のシーケンスのみサポートする。\begin{quote}\begin{jverbatim}sequence       Character represented\n             改行(LF)\t             タブ\\             \記号\'             'シングルクオート (""中)\"             "ダブルクオート (''中)\:             :コロン (''中)\end{jverbatim}\end{quote}Konoha は、文字を表現するための特別な型は存在せず、1文字の文字列として表現する。そのため、シングルクオート(')も、他の多くのスクリプティング言語と同様に文字列リテラルの始まりと終わりとして利用可能である。シングルクオートを用いると、"を含む文字をすっきりと表すことができる。\begin{quote}\begin{jverbatim}'Say "hi"'\end{jverbatim}\end{quote}シングルクオートは、正式には「タグ付き文字列」のリテラルとして用いられる。もしシングルクオートを文字列リテラルとして利用するときは、コロン(:)もエスケープ記号として扱う必要がある。詳しくは、「第\ref{chapter:semanticprogramming}章 セマンティックプログラミング」を参照せよ。\subsection{トリプルクオート}トリプルクオートは、Python に由来するテキスト用の文字リテラルである。''' もしくは、""" で囲まれたテキストは、改行やタブ文字もそのまま文字列として扱われる。ただし、エスケープシーケンスも有効である。\begin{quote}\begin{jverbatim}'''This is a rather long string containingseveral lines of text just as you would do in C.    Note that whitespace at the beginning of the line is significant.'''\end{jverbatim}\end{quote}Konoha のトリプルクオートは、読みやすさを向上するためのちょっとした改良を加えてある。トリプルクオートの先頭が改行の場合は、それは無視される。したがって、上記の文字列は、"T"から始まる。\subsection{RAW 文字列}RAW文字列とは、エスケープシーケンスを無視した文字列リテラルである。Konoha は、C\# に由来する記法を採用し、文字リテラルの前に@を付加するとRAW文字列として用いられる。\begin{quote}\begin{jverbatim}@"C:\My Document\Programming\Konoha"\end{jverbatim}\end{quote}\subsection{ラインリテラル}Konoha 独自\begin{quote}\begin{jverbatim}#\end{jverbatim}\end{quote}\subsection{文字リテラルの連結}文字リテラルは、複数並べると、自動的に連結されてひとつの文字列となる。\begin{quote}\begin{jverbatim}"hello" "," "world"　　  // "hello,world"と同じ\end{jverbatim}\end{quote}文字リテラルの間に改行があると、連結するとき自動的に改行が挿入される。\begin{quote}\begin{jverbatim}# create table book (#    name char[20];#    title char[80];# );\end{jverbatim}\end{quote}\section{文字列と演算子}\subsection{長さとシーケンス}文字列は、0個以上の文字が並んだシーケンスである。Konohaでは、シーケンス s は、\verb#|s|# 演算子を用いることで、その長さを得ることができる。文字列の場合、そこに含まれる文字の数である。\begin{quote}\begin{jverbatim}>>> s = "";　　>>> t = "ABC"; >>> u = "ABCいろは";>>> |s|0>>> |t|3>>> |u|6\end{jverbatim}\end{quote}Konohaの文字列の長さは、多国語化された設計となっているため、文字のバイト数に関わらず、文字数が文字列の長さとなる。ASCII(1バイト)文字列を前提としたバイト数でないことに注意したい。もし文字列のバイト数をしりたい場合は、一旦、バイト配列(\verb|byte[]|)に変換すればよい。ただし、このときUTF8エンコーディングが用いられ、それにしたがい日本語は3バイト以上になっている。\begin{quote}\begin{jverbatim}>>> s = "ABCいろは";>>> b = (byte[])s;>>> |b|12\end{jverbatim}\end{quote}文字列は、文字の配列として扱うことができる。配列のインデックスは、0から始まり、\verb#|s| - 1# である。\begin{quote}\begin{jverbatim}>>> s = "ABCいろは";>>> s[0]"A">>> s[|s|-1]            // 最後の一文字"は"\end{jverbatim}\end{quote}注意：Konoha の文字列は、変更不能(immutable)である。通常の配列のように値を変更することができない。文字列から部分文字列を取り出すときは、シーケンススライス演算子を用いることができる。\begin{quote}\begin{jverbatim}>>> s = "ABCいろは";>>> s[..2]"ABC">>> s[3..]"いろは">>> s[2..4]"Cいろ"\end{jverbatim}\end{quote}\subsection{連結と四則演算}文字列の連結は、Java と同様に、加算(+)演算子によって書くことができる。この加算は、もちろん結合則や交換則に基づくものではないが、操作が直感的であり、広く使われている。\begin{quote}\begin{jverbatim}>>> "Uzumaki" + " " + "Naruto""Uzumaki Naruto"\end{jverbatim}\end{quote}Konoha は、文字列の加算を最も優先されるオペレータとして定義している。つまり、文字列と文字列以外のオブジェクトを混在して換算した場合、全て文字列に変換されたのち連結される。\begin{quote}\begin{jverbatim}>>> "Naruto " + 8 + 1            // %s(8) + %s(1)と同じ"Naruto 81"\end{jverbatim}\end{quote}もし数値演算を優先したい場合は、括弧()で囲んで先に計算する。\begin{quote}\begin{jverbatim}>>> "Naruto " + (8 + 1)          // %s(8 + 1)と同じ"Naruto 9"\end{jverbatim}\end{quote}Konohaでは、加算に加えて、減算、乗算、割り算の演算子にもそれぞれ定義されている。これらも数学的な性質は継承しないが、文字列処理としてときに便利である。文字列の減算 \verb|s - t| は、文字列 s から指定された文字列 t を取り除く操作である。これは、\verb|s.replace(t, "")|に相当する。\begin{quote}\begin{jverbatim}>>> "Uzumaki Naruto" - "a" - "u";"Uzmki, Nrto"\end{jverbatim}\end{quote}文字列の乗算\verb|s * n|は、文字列の四則演算の中で唯一整数値を引数にとる。しかし、そこから得られる結果は極めて直感的に、文字列s を n個連結したものである。\begin{quote}\begin{jverbatim}>>> "Naruto" * 3;"NarutoNarutoNaruto">>> "hello" * 0""\end{jverbatim}\end{quote}文字列の除算\verb|s / t|は、文字列 s を文字列tで分割したときの先頭の文字列である。文字列の余算\verb|s % t|は、分割された残りの文字列となる。これは、\verb|s.split(t)|の簡易版として利用される。\begin{quote}\begin{jverbatim}>>> "Uzumaki Naruto" / " ""Uzumaki">>> "Uzumaki Naruto" % " "            // mod のこと"Naruto"\end{jverbatim}\end{quote}\subsection{文字列の比較}文字列は、関係演算子によって比較することができる。そのとき、単純にアルファベットオーダー(UTF8 のコード順)で比較され、英大文字/英小文字は無視されない。\begin{quote}\begin{jverbatim}>>> "Uzumaki" == "Naruto"false>>> "Uzumaki" > "Naruto"ture\end{jverbatim}\end{quote}\section{文字列メソッド}Konohaは、Java由来のメソッド を標準的にサポートしている。\subsection{startsWith(), endsWith()}\subsection{indexOf(), lastIndexOf()}\subsection{toUpper(), toLower()}\subsection{split()}\subsection{replace()}\subsection{パッケージによる拡張}Konoha は、実行中であってもクラスに新しいメソッドを追加したり、既存の振る舞いを変更することができる。{\sf String} クラスも例外ではなく、パッケージのインポートによって、メソッドが拡張されることがある。\begin{quote}\begin{jverbatim}>>> using japanese;                 // 日本語パッケージ>>> ("なると").toKata()	            // カタカナへの変換"ナルト">>> ("ナルト　").trim()             // 全角空白も除去される"ナルト"\end{jverbatim}\end{quote}\section{テンプレート・フォーマッティング}テンプレートフォーマッティングは、Konohaの独自機能であるフォーマッタを用いてテンプレートを作成し、それに基づいてフォーマッティングする機能である。アイディアは、Python のフォーマット文字列 \verb|%|に由来するが、C\#風のインデックスをサポートしている。\begin{quote}\begin{jverbatim}>>> %("%s{1}: %d{0}='%bits{0}'", 2, "flag")flag: 2=00000000 00000000 00000000 00000010\end{jverbatim}\end{quote}\subsection{テンプレートの書式}テンプレートは、定められた書式にしたがい文字列で作成する。文字列リテラルとして直接与えることも、変数に格納して再利用することも可能である。書式は、\verb|"%x{n}"|スタイルで、「フォーマッタ\verb|%x|に n 番目のパラメータを適用する」と意味になる。ここでインデックスは、0 から始まる。わざわざ、パラメータのインデックスを指定できる理由は、英語と日本語のような語順が違うテンプレートでも、パラメータの順番を気にしなくて適用するためである。\begin{quote}\begin{jverbatim}>>> fmt = """... print "name";... print "name"... """\end{jverbatim}\end{quote}\subsection{フォーマッティング}テンプレートは、名前無しの特殊なフォーマッタ関数 \verb|%()|を用いて、フォーマッティングされる。フォーマットされた文字列は、関数の戻り値として返される。\begin{quote}\begin{jverbatim}>>> %(fmt, n, n)\end{jverbatim}\end{quote}フォーマッティング時のパラメータは、Konohaにおいて数少ないコンパイル時に型検査されないパートである。フォーマッタは、与えられたパラメータのクラスに対して、動的にバインドされる。もし指定されたフォーマッタが定義されてなければ、自動的に \verb|%empty|が適用され、そこには文字列が表示されない。もし厳密な型検査を求める場合は、関数等でラッピングして用いるとよい。\subsection{ダイレクトフォーマット}Konoha では、\verb|#|で始まるライン文字列リテラルに対してのみ、インデックスの代わりに、変数やその他の式を直接埋め込むことができる、ダイレクトフォーマッティングを認めている。\begin{quote}\begin{jverbatim}c.query 	# select name, salary from persontbl	# where age > %d{age} and age < %d{age2}\end{jverbatim}\end{quote}\section{正規表現}%プログラミング言語が提供する最も強力な文字列能力は、正規表現である。