\chapter{デバッグ}スクリプティング言語は、一般に「プログラミングしやすい」言語と考えられている。それは、スクリプティング言語による開発において、あまり深刻なバグに悩まされる機会が少ないからである。しかし、どんなソースコードにもバグは存在し、そのバグを解析し、修正する作業が必要となる。\section{デバッグモード} \index{でばっぐもーど@デバッグモード}\index{りりーすもーど@リリースモード}Konoha の実行モードは、デバッグモードとリリースモードの2種類ある。デバッグモードは、開発者向けのデバッグ情報を出力しながら実行するモードである。リリースモードは、一般のユーザからの利用を前提として、開発者向けの情報を抑制して実行するモードである。Konoha は、通常、リリースモードでスクリプトを実行する。デバッグモードで実行する場合は、起動オプションに \verb|-g| を用いる。\begin{quote}\begin{jverbatim}$ konoha -g script.k\end{jverbatim}\end{quote}注意：対話モードは、\verb|-g|を付けなくてもデバッグモードとして起動される。Konohaによるスクリプトの実行は、厳密に言えば、コンパイルとコンパイル済みのコードの実行からなる。デバッグ/リリースモードは、この両者に適用される。特に、リリースコンパイル時は、実行速度向上と利用メモリ量軽減を意図したコード最適化のため、デバッグコンパイルと異なるコードが生成される。\subsection{実行時のモード切り換え} Konoha内部では、デバッグ/リリースモードの切り換えは、実行コンテクストによって行っている。そのため、実行中にモードを切り替えることもできる。\begin{quote}\begin{jverbatim}Context.setDebug(false);           // リリースモードに変更\end{jverbatim}\end{quote}リリースコンパイル済みのコードは、実行時にデバッグコードに変更しても、デバッグ情報が得られない。逆に、デバッグコンパイルされたコードは、実行時にリリースモードに変更すると、デバッグ情報の出力は抑制される。これは、デバッグコンパイルは、コードの最適化がなされないためである。\begin{quote}\begin{jverbatim}Context.setDebug(true);            // デバッグモードに変更\end{jverbatim}\end{quote}\subsection{{\sf @Release} アノテーション} \index{release@Release}クラス宣言やメソッド定義のとき、\verb|@Release| アノテーションを付けると、その対象となるクラスとメソッドは、デバッグモードでコンパイルされても常にリリース版のコードが生成される。十分に開発が完了した部分は、\verb|@Release| アノテーションを付けることで、開発チームにもコンパイラにも開発の進捗を明確に伝えることができる。\begin{quote}\begin{jverbatim}@Release class Person {}\end{jverbatim}\end{quote}注意: クラスに、\verb|@Release|アノテーションを付けると、そのクラスの全てのメソッドがリリースとなる。\section{{\sf DEBUG}ブロック} \index{DEBUG@DEBUGブロック}DEBUG ブロックは、デバッグ版スクリプト用のブロックである。リリースモードでコンパイルされると、このコードブロックは無視される。\begin{quote}\begin{jverbatim}DEBUG {	// リリース版コードでは取り除かれる	}\end{jverbatim}\end{quote}\section{{\sf print} 文} \index{print@print文}Konohaにおける正式なプリントアウト方法は、いわゆる{\sf OUT}定数による{\sf OutputStream}クラスを用いた標準出力である。一方、{\sf print} 文もサポートしている。今どき、{\sf print}文のような専用ステートメントを持つのは古めかしい印象かも知れないが、クラスルームにおいて、「print デバッグ」を教えるとき {\sf print}文がないと都合がわるいからである。もちろん、誰にとっても「{\sf print} デバッグ」は有効であり、Konohaにおける {\sf print} 文は、「print デバッグ」専用の機能を備えている。print 文は正式なプログラムの一部ではなく、デバッグ/リリースモードによって、プリントアウト出力のありなしが切り替わる。リリースコンパイルでは、そもそも{\sf print}自体、無視される。もうひとつの特徴は、{\sf print} 文は、デバッグ情報として加工された情報が出力されることである。まず、必ず {\sf print文} が実行された位置がメソッド名+行番号、もしくはファイル名+行番号として出力される。変数の値出力の場合は、変数名も出力される。\begin{quote}\begin{jverbatim}>>> a = 0;>>> print a;[shell.c:4] a=0\end{jverbatim}\end{quote}単一のprint 文において、複数の情報を出力する場合は、カンマで区切る。\begin{quote}\begin{jverbatim}>>> a = 0; >>> b = 1;>>> print a, b, (a+b);[shell.c:4] a=0, b=1, (a+b)=1\end{jverbatim}\end{quote}\section{{\sf assert}文} \index{assert@assert文}アサーション(assertion)は、表明と訳される。{\sf assert}文は、プログラムが正しく動作するための前提条件を表明し、プログラムが表明された条件通り正しく動作しているか確認するデバッグ機能を提供する。まず、正しいプログラムという概念を考えるため、簡単な例を用いて考えてみたい。次の\verb|fibo()|関数は、引数\verb|n|において\verb|n > 0|を満たす整数が与えられるという前提でプログラミングしてある。しかし、利用者の方は原理的に\verb|fibo(-1)|とコールすることもできる。（その場合は、\verb|StackOverflow!!|がスローされる。）\begin{quote}\begin{jverbatim}int fibo(int n) {	if(n == 1 || n == 2) return 1;	return fibo(n-1) + fibo(n-2);}\end{jverbatim}\end{quote}このバグは、負の数でも動作するように\verb|fibo()|関数を作らなかった方に責任があるのか、それとも\verb|fibo(-1)|をコールした方が悪いのか、という問題が発生する。どちらにバグの責任があるかはっきりしない場合は、デバッグすることができない。今回は、負のフィボナッチ数列は通常、定義されていないため、そもそも負の数を処理することはできない。もし関数を修正する場合は、例外をスローする方法も考えられる。\begin{quote}\begin{jverbatim}int fibo(int n) {	if(n > 0) {		if(n == 1 || n == 2) return 1;		return fibo(n-1) + fibo(n-2);	}	throw new Arithmetic!!("Negative fibo");}\end{jverbatim}\end{quote}逆に、\verb|fibo(-1)|を呼び出した方をバグとみなしたい場合がある。そのような場合は、\verb|fibo(n)|の正しい動作条件を表明しておく必要がある。次のように、実行する前に{\sf assert}文を用いれば、その表明となる。\begin{quote}\begin{jverbatim}int fibo(int n) {	assert(n > 0);	if(n == 1 || n == 2) return 1;	return fibo(n-1) + fibo(n-2);}\end{jverbatim}\end{quote}{\sf assert} 文は、実行時チェックが行われるため、もし表明に違反した場合は、\verb|Assertion!!|例外がスローされる。これにより、表明に違反したコードを探して、デバッグを行うことができる。\begin{quote}\begin{jverbatim}>>> fibo(-1)** Assertion!!: n > 0\end{jverbatim}\end{quote}注意すべき点は、{\sf assert}文はデバッグ用のステートメントである点である。リリース前に、徹底的にソフトウェアテストを行い、\verb|Assertion!!|例外が発生しないようにデバッグする必要がある。(通常、{\sf assert}文は分岐命令を利用するため、実行速度面で不利になる。）\subsection{リリース・アサーション} \index{りりーすあさーしょん@リリース・アサーション}アサーションは、通常、デバッグ用の機能である。しかし、リリース版であっても、致命的な実行結果をもたらす前に、アサーション機能によって処理を中断させたいと考える場合もある。Konohaでは、\verb|@Release|アノテーションを{\sf assert}文の前に追加することで、リリースコンパイル時でも{\sf assert 文}がコード生成されるようになる。\begin{quote}\begin{jverbatim}@Release assert(n > 0);\end{jverbatim}\end{quote}注意：頻繁にアクセスされる箇所に、リリース・アサーションを用いると、性能低下の原因となる。リリース・アサーションの導入は慎重に検討すべきである。\section{{\sf utest}文*}Konohaプロジェクトでは、ユニットテストをサポートするための専用のステートメントを導入したいと考えている。\begin{quote}\begin{jverbatim}@Name("test name")utest (n > 0) {      // テスト結果の表明	// テストコード}\end{jverbatim}\end{quote}\section{ブレークポイント*} Konohaの対話モードでは、デバッガ(gdb)の代表的なデバッグ機能をサポートしたいと考えている。これらの機能は、バイトコードの実行時書き換えのAPIが整備したのち、拡張される予定である。