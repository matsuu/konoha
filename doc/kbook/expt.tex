\chapter{例外処理}例外は、動的な非局所ジャンプの一種である。\section{例外クラス Exception}{\sf Exception}は、例外の種類、状態を表現するクラスである。クラス {\sf Exception} は、Konoha において例外を実現する唯一のクラスである。例外の種類は、例外クラス内部の表現として分類され、どの例外も{\sf Exception} クラスのインスタンスとなる。\begin{kshell}>>> e = new Security!!();>>> e.classException>>> e = new IO!!();>>> e.classException\end{kshell}\section{{\sf throw} 文} \index{throw@throw文}Konohaは、プログラム実行中に何らかの異常を検出したとき、例外をスローする。例えば、0除算が発生した場合、その異常状態は\verb|Arithmetic!!|例外がスローされたことで知ることができる。\begin{kshell}>>> a = 0;>>> 1 / a;** Arithmetic!!: Divide by Zero\end{kshell}同様に、プログラマ自身も、専用のステートメント {\sf throw} を使うことによって、例外をスローすることができる。最も標準的な例外のスローは、新しく例外クラスを作成し、それを{\sf throw} 文に与える方法である。\begin{kshell}>>> throw new Security!!("Something wrong");** Security!!: Something wrong\end{kshell}Konoha の{\sf throw}文では、文字列（エラーメッセージ）をそのまま投げることができる。文字列の先頭が例外名のタグであれば、例外の種類が適切に判別され、そうでなければ単純に\verb|Exception!!|になる。\begin{kshell}>>> throw "Security!!: Something wrong";** Security!!: Something wrong\end{kshell}%例外をスローすると、プログラムの正常化を行うため、{\sf catch}文によって捕捉されるまで大域的にジャンプする。ただし、異常の状況が軽度な場合は、エラーの記録にとどめておけば十分な場合も多く、{\sf throw}文の代わりに {\sf warn}文を入れ替えることでログ出力に変更できる。%%\begin{kshell}%warn "Security!!: Something wrong";%\end{kshell}%\section{{\sf try-catch}文} \index{try@try文} \index{catch@catch節}{\sf try-cacth}文は、{\sf try}ブロック内で発生した例外を捕捉（キャッチ）し、プログラムの正常化を行うための制御構造である。\begin{kshell}try {	// ブロックでスローされた例外に対する}catch(IO!! e) {	// プログラムの正常化}\end{kshell}{\sf catch} 節は、複数種類の例外をそれぞれ処理することができる。例外はソースコードの順に先頭からマッチング処理を行われ、最初にマッチングした {\sf catch}節が処理される。マッチングは、\verb|e instanceof E!!|による半順序マッチングであり、複数の{\sf catch}節の条件にマッチする可能性があるが、最初のひとつ以外は{\sf catch}節は無視される。\begin{kshell}try {	// ブロックでスローされた例外に対する}catch(Security!! e) {	// プログラムの正常化}catch(SQL!! e) {	// プログラムの正常化}catch(IO!! e) {	// プログラムの正常化}\end{kshell}また、どの{\sf catch}節の例外処理にもマッチしなかった場合は、例外は捕捉されることなく、そのまま継続してスローされ続ける。\section{{\sf finally}節}　\index{finally@finally節}%\section{{\sf Security!!}例外}