\chapter{数値 Int, Float}コンピューティングプロセッサ (CPU) は、コンピュータシステムの中心部であり、様々な形式の整数や浮動点小数の演算をサポートしている。プログラミング言語は、これらを, 例えばC言語の場合、{\sf char}, {\sf short}, {\sf int}, {\sf long} {\sf long long int}, {\sf float}, {\sf double}, {\sf long double}のように、異なる型で区別して利用できるようになっている。一方、Konoha は、プロセッサの性能やメモリ効率を最大利用するより、プログラミングのしやすさに力点を置いている。そのため、最も使いやすい整数と浮動小数点の形式を選んで、{\sf Int} と {\sf Float}クラスとしてサポートしている。この章では、これらのクラスに関して説明をする。% Integers are the most basic data type. Konoha differs from programming languages such as C and Java in that it does not make a distinction between short integers and long integers. All integers in Konoha are represented as values of the Int class. Konoha represents integers using the 64-bit integer number, which means it can represent integers ranging - to + (inclusive).% Floating-point numbers are another basic datatype. All floating-point numbers in Konoha are represented as values of the Float class. Unlike the name implies, Konoha represents floats using the 64-bit floating-point format defined by the IEEE 745 standard, called double in C, C++, and Java.\section{数値リテラル}数値リテラルは、文字列リテラルと並んでもっとよく利用されるリテラルである。\subsection{整数リテラル}%3.2.1	Integer Literals%In a Konoha program, a base-10 integer is written as a sequence of digit. For example:Konohaは、{\sf short}や{\sf long}などサイズの異なる整数を使い分ける可能性は少なく、単純に自然数を表すために整数を用いると想定される。{\sf Int}クラスでは、値の上限下限を最も気にしなくて済む64ビット整数\footnote{\verb|KNH_USING_INT32|オプションを用いれば、32ビット整数に変更することも可能である。}を採用している。Konohaでは、10進数の整数は、数字の列として書ける。値の範囲は、-9223372036854775807から9223372036854775807となる。\begin{quote}\begin{jverbatim}03100000000\end{jverbatim}\end{quote}%3.2.2	Hexadecimal and Binary Literals%In addition to base-10 integer literals, Konoha recognizes hexadecimal (base-16) values. A hexadecimal literal begin with "0x" or "OX", followed by a string of hexadecimal digits, one of digits 0 through 9 or the letters a (or A) through f (or F), which represent values 10 through 15. Here are examples of hexadecimal integer literals:10進数表記に加えて、Konoha は、16進表記と2進表記をサポートしている。16進表記の整数リテラルは、\verb|0x|もしくは\verb|0X|で始まり、続いて数字(0-9)もしくは10から15までの数字を表す英字(A-F)が続く形式である。\begin{quote}\begin{jverbatim}0xff                             // 15 * 16 + 15 = 2550xCAFE911\end{jverbatim}\end{quote}%In addition to hexadecimal literals, Konoha allow you to specify integer literals in binary (base-2) format. An binary literal begins with "0b" or "OB" and is followed by a sequence of digits, each 0 or 1. For example:2進表記の整数リテラルは、クラスルーム利用のための拡張である。\verb|0b| もしくは、\verb|0B|から始まり、0もしくは1が続く2進数で値を与えることができる。\begin{quote}\begin{jverbatim}0b1111                           // 0xff = 255 \end{jverbatim} \end{quote}\subsection{Float リテラル}%3.3	Floating-Point Numbers%3.3.1	Floating-Point Literals% Floating-point numbers are another basic datatype. All floating-point numbers in Konoha are represented as values of the Float class. Unlike the name implies, Konoha represents floats using the 64-bit floating-point format defined by the IEEE 745 standard, called double in C, C++, and Java.浮動小数点数(floating-point numbers) は、全て {\sf Float}クラスの値として表現される。その名前から想像されるものとは異なり、IEEE 745 標準で定義された64ビット倍精度形式を用いている。これらは、C/C++, Java言語では、通常 {\sf double}型で表現される形式である。% Floating-point literals can have a decimal point; they use the traditional syntax for real numbers. A real value is represented as the integral part of the number, followed by a decimal point and the fractional part of the number.Float リテラルは、小数点を必ず含む。通常、整数パートの数列に始まり、小数点、続いて小数点以下の数列が続く形式である。また、eもしくはEによって$10 ^ n$乗形式の位を追加することも可能である。% Floating-point literals may also be represented using exponential notation: a real number followed by the letter e (or The E), followed by an optional plus or minus sign, followed by an integer exponent. This notation represents the real number multiplied by 10 to the power of the exponent.More succinctly, the syntax is: [digits][.digits][(E|e)[(+|-)]digits]\begin{quote}\begin{jverbatim}3.142345.789.333333333336.02e231.473E-32\end{jverbatim}\end{quote}%Note that there are infinitely many real numbers, but only a finite number of them (, to be exact) can be represented exactly by the Konoha floating-point format.\section{数値と演算子}\subsection{四則演算}{\sf Int}, {\sf Float}は、それぞれの型の範囲において四則演算(+,-,*./)を定義している。つまり、{\sf Int}型間の演算では{\sf Int}型の結果がえられ、{\sf Float}型間の演算では、結果は{\sf Float}型になる。\begin{quote}\begin{jverbatim}>>> 7 / 2                  // Int型の除算3>>> 7.0 / 2.0              // Float型の除算3.5000000\end{jverbatim}\end{quote}一方、{\sf Int}型と{\sf Float}型を混在して演算したときは、{\sf Int}型の値は全て自動的に{\sf Float}型に変換されたのち、演算される。したがって、結果は{\sf Float}型となる。\begin{quote}\begin{jverbatim}>>> 7 / 2.0               // 7は7.0へ3.5000000>>> 7.0 / 2               // 2は、2.0へ3.5000000\end{jverbatim}\end{quote}ゼロ除算の場合は、{\sf Int}, {\sf Float}ともに、\verb|Arithmetic!!|例外が通知される。\begin{quote}\begin{jverbatim}>>> 1 / 0                 // ゼロ除算Arithmetic!!: Zero Divide\end{jverbatim}\end{quote}\subsubsection{優先順位}Konoha の四則演算は、日常の数学の演算と同じ順序で計算される。つまり、乗算と除算は、加算と減算に優先して実行される。演算の優先順位を変更するときは、優先対したい演算を()で囲む。\begin{quote}\begin{jverbatim}>>> 1 + 2 * 37>>> (1 + 2) * 39\end{jverbatim}\end{quote}Konohaでは、四則演算以外にも数多くの演算子をサポートしている。これらを混在して利用するときは、優先する演算子を()で囲む習慣をつけると、思わぬ誤動作を防ぎ、また読みやすさも向上する。\subsection{比較演算}{\sf Int}型, {\sf Float}型は、ともに比較演算子(==, !=, <, <=, >=, >)によって数値を比較できる。{\sf Int}型は、ほとんど問題はおこらないが、{\sf Float}型の場合は、オリジナルのIEEE 浮動小数点規格に基づく、誤解が発生する。\subsection{数値変換}Konohaでは、Int型とFloat型の型変換は、必要に応じて自動的に行われる。これらを明示的におこないたい場合は、キャスト演算を用いることができる。ただし、Konohaの数値変換の振る舞いは、C言語の数値変換の振る舞いに基づいている。特に、{\sf Float}から{\sf Int}への変換は、切り捨てになるため注意が必要である。\begin{quote}\begin{jverbatim}>>> (int)1.81>>> (int)-1.8-1\end{jverbatim}\end{quote}小数点以下 n 桁で切り上げ、四捨五入、切り下げを行いときは、{ｴsf math}パッケージのクラス関数\verb|Math.ceil()|, \verb|Math.round()|, \verb|Math.floor()|を用いる。\begin{quote}\begin{jverbatim}>>> using math.*;>>> Math.ceil(1.8, 0)2.0000000>>> Math.round(1.8, 0)2.0000000>>> Math.floor(1.8, 0)1.0000000\end{jverbatim}\end{quote}\subsection{文字列との変換}Konohaは、全てのクラス間の変換がキャスト演算子に統合されている。文字列への変換も文字列からの変換もキャストで行うことができる。ただし、数値の書式を指定したい場合は、次節のフォーマッタを用いる。\begin{quote}\begin{jverbatim}>>> (String)1.8"1.8000000">>> (int)"123"123\end{jverbatim}\end{quote}文字列から数値への変換は、数値リテラルの解釈と同等に行われる。\begin{quote}\begin{jverbatim}>>> (int)"0xff"255>>> (float)"6.0221415e23"602214149999999896780800.000000\end{jverbatim}\end{quote}数値以外の文字列は、それぞれ{ｴsf Int}型、{ｴsf Float}型のデフォルト値へ変換される。明示的に変換できなかったことを得たいときは、Nullable キャストを用いることができる。このときは、{ｴsf null}が得られる。\begin{quote}\begin{jverbatim}>>> (int)"hello,world"         // 数値でない0>>> (int?)"hello,world"        // 数値でないnull\end{jverbatim}\end{quote}\subsection{ビット演算}Konohaは、{\sf Int}型の数値のみ、ビット演算をサポートしている。\begin{quote}\begin{jverbatim}\end{jverbatim}\end{quote}Floatの値をIEEE 754 浮動小数点のビットレイアウトにしたがってビット演算したいときは、\verb|Float.floatToIntBits()|を用いて{\sf Int}型へ変換したのち、\verb|Float.intBitsToFloat()|で{\sf Float}型に変換すればよい。\begin{quote}\begin{jverbatim}>>> \end{jverbatim}\end{quote}\section{フォーマッタ}\subsection{フォーマッタ}\section{乱数生成}乱数生成は、{\sf Int}と{\sf Float}クラスのそれぞれのランダムな値を生成することである。Konoha では、乱数生成器として統計処理にも広く利用される高品質なアルゴリズム Mersenne Twister \cite{mt} を採用している。\begin{itemize}\item \verb|Int Int.random(Int? n)| - 疑似乱数 x ($<n$)を生成する。\item \verb|Float Float.random()| - 疑似乱数x ($0.0 < x < 1.0$)を生成する。\end{itemize}乱数生成の最小値は、0となる。\begin{quote}\begin{jverbatim}>>> Int.random(6)+1           // さいころ(1 〜 6 の乱数)3\end{jverbatim}\end{quote}通常、乱数生成器を初期化する必要はない。ただし、明示的に乱数生成器を初期化したいときは、\verb|System.setRandomSeed(Int? n)|を用いることができる。\section{Decimal}