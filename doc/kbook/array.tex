\chapter{配列 Array}配列は、複数の要素を扱う最も基本的なデータ構造である。Konohaの配列は、可変長のGrowing Array であり、リストとしても利用できる。\section{配列と型}Konoha の配列は、要素の型のから2種類に分類される。ひとつは、任意の型の要素をもちえる{\sf Array}クラスと、もうひとつある特定の型Cの要素のみもちえる\verb|C[]|である。両者は、ともに{\sf Array}の総称型の別名であり、基本的な性質は同じである。\begin{quote}\begin{jverbatim}Konoha        総称型Array         Array<Any>           C[]           Array<C>String[]      Array<String>   \end{jverbatim}\end{quote}{\sf Array}と{\sf C[]}は、要素の型以外に大きな違いはない。しかし、{\sf Array}型は、Any型がnullを認めるため、null を要素にもつことができるのに対し、{\sf C[]}型は、null を要素にもつことができない。\section{配列の生成}配列は、配列リテラルで新しい配列を与える場合とコンストラクタを用いて配列を作る場合の2種類の方法がある。\subsection{配列リテラル}配列リテラルは、Python や JavaScript などで採用されている\verb|[]|コンストラクタを用いる。重要な違いは、リストの要素によって配列の型が推論される点である。配列リテラルの要素がすべて型Cのときは、\verb|C[]|となり、そうでないときは{\sf Array}クラスとなる。 \begin{quote}\begin{jverbatim}[]                        // 空の Array[1,2,3]                   // Int[] の配列["Naruto", "Sakura"]      // String[]の配列["Naruto", 9]             // Array\end{jverbatim}\end{quote}\subsection{Array コンストラクタ}{\sf Array}のコンストラクタは、2種類存在する。ひとつは、空のArrayを作る方法である。ただし、Konoha のArrayは、Growing Array であり、初期値パラメータを与えておくと効率よく成長する。\begin{quote}\begin{jverbatim}>>> a = new Array(10);    // 空のArrayを生成>>> a[]\end{jverbatim}\end{quote}もうひとつは、Java 言語と同様に、配列の大きさをあらかじめ当てはめて宣言する方法である。\begin{quote}\begin{jverbatim}>>> a = new Any[4];       // 要素数n個の配列>>> a[null, null, null, null]\end{jverbatim}\end{quote}\subsection{{\tt C[]}コンストラクタ}配列のコンストラクタは、Java 言語と同様に、配列の大きさをあらかじめ当てはめて宣言する方法である。\begin{quote}\begin{jverbatim}>>> ss = new String[4];        // 要素数4個の配列String[]>>> ss["", "", "", ""]\end{jverbatim}\end{quote}生成された配列の要素は、要素型のデフォルト値(\verb|default(C)|)で満たされる。(Javaと異なり、null ではない。) デフォルト値が不都合な場合は、要素数を0にして空の配列を生成したのち、追加することになる。\begin{quote}\begin{jverbatim}>>> ss = new String[0];        // 空のString[]>>> ss[]\end{jverbatim}\end{quote}\section{配列と演算子}配列は、0個以上の要素が並んだシーケンスである。Konohaでは、シーケンス s は、\verb#|s|# 演算子を用いることで、その長さを得ることができる。配列の場合は、要素の数である。\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2, 3]>>> |a|4\end{jverbatim}\end{quote}配列\verb|a|のインデックスは、C/C++, Java言語と同様に 0 から始まり、\verb#|a| - 1# である。その範囲を超えると、\verb|OutOfIndex!!|例外が通知される。\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2, 3]>>> a[0]0>>> a[|a|-1]3>>> a[4]OutOfIndex!!\end{jverbatim}\end{quote}配列は、基本的に変更可能である。正しいインデックスを指定すれば配列の値を変更できる。\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2, 3]>>> a[1] = 10>>> a[0, 10, 2, 3]\end{jverbatim}\end{quote}配列\verb|a|から部分配列を取り出すときは、スライス演算子\verb|a[m..n]|を用いることができる。$m$と$n$は、省略可能で、省略した場合は、それぞれ0と最後の添字(\verb#|a|-1#)と解釈される。\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8]>>> a[2..]                       // a[2]から[2, 3, 4, 5, 6, 7, 8]>>> a[2..6]                      // a[2]からa[6]まで[2, 3, 4, 5, 6]>>> a[..<6]                      // a[2]からa[5]まで[2, 3, 4, 5]>>> a[2..+6]                     // a[2]から6個[2, 3, 4, 5, 6, 7]>>> a[..6]                       // a[6]まで[0, 1, 2, 3, 4, 5, 6]>>> a[..<6]                      // a[6]まで（含まない)[0, 1, 2, 3, 4, 5]>>> a[..+6]                      // 最初の6個[0, 1, 2, 3, 4, 5, 6]\end{jverbatim}\end{quote}注意：初期のKonohaでは、python 風のシーケンスの最後尾からインデックスを数える $-n$ 表記が利用できた。このインデックスは便利であったが、C/C++, Java などの既存の配列との互換性（相互運用生）や最適化処理の困難さを理由に廃止となった。\section{多次元配列}Konohaの配列は、基本的に1次元配列である。これを、あたかも2次元、3次元配列として利用ようにシンタックスシュガーが用意されている。\begin{quote}\begin{jverbatim}>>> a = new Int[10, 10];         // 2次元配列>>> a = new Int[10, 10, 10];     // 3次元配列>>> typeof(a)Int[]\end{jverbatim}\end{quote}\section{配列とメソッド}Konohaは、JavaのCollection フレームワークの標準的なメソッドをベースにして{\sf Array}関係のメソッドを定義している。\subsection{リスト: add(), insert(), remove()}Konohaの配列は、全て可変長であり、リストのように要素数のわからないデータを実行時に必要に応じて伸縮させながら利用できる。メソッド\verb|add(v)|は、最もよく使われるメソッドである。配列の最後尾に新しい要素ｴverb|v|を追加する。演算子 \verb|<<|と同じ働きをする。\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2]>>> a.add(100)　　　　　　　　　　// 追加>>> a[0, 1, 2, 100]>>> a.add(30000)                  // 追加>>> a[0, 1, 2, 100, 300000]\end{jverbatim}\end{quote}メソッド\verb|insert(n, v)|は、ｴverb|n|番目に要素ｴverb|v|を挿入するときに利用し、メソッド\verb|remove(n)|は、ｴverb|n|番目からを取り除くとき利用する。どちらの場合は、配列の大きさは、それぞれ増減する。\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2]>>> a.insert(1, 100)　　　　　　　// 挿入>>> a[0, 100, 1, 2]>>> a.remove(2)                   // 削除>>> a[0, 100, 2]\end{jverbatim}\end{quote}Konohaの配列は、リストのように利用できるが、純粋なリストデータではないため、\verb|insert(), remove()|ともに配列をコピーするだけのコストがかかる。\verb|add()|は、十分に高速に要素を追加することができる。\subsection{キューやスタック: first(), pop()}Konohaの配列は、キュー(FIFO)やスタック(FIFO)として利用することができる。\begin{quote}\begin{jverbatim}>>> queue = []>>> queue.add(1)                  // キューに追加>>> v = queue.first()             // キューから取り出す\end{jverbatim}\end{quote}\begin{quote}\begin{jverbatim}>>> stack = []>>> stack.add(1)                  // スタックに追加>>> v = stack.pop()               // スタックから取り出す\end{jverbatim}\end{quote}\subsection{swap(), reverse(), shuffle()}Konohaは、...\begin{quote}\begin{jverbatim}\end{jverbatim}\end{quote}\subsection{整列：sort()}Konohaは、十分に高速なソートアルゴリズムによって配列の要素の並びをソートすることができる。\begin{quote}\begin{jverbatim}>>> a = [0, 2, 1]>>> a.sort()        　　　　　　　// ソート>>> a[0, 1, 2]\end{jverbatim}\end{quote}\subsection{サーチ: indexOf(), lastIndexOf(), binarySearch()}サーチは、配列中から指定された要素を探すことである。配列は、ｴverb|indexOf()|は、先頭から探して最初に見つかったインデックスを返す。ｴverb|lastIndexOf()|は、逆に最後尾から検索して最初に見つかった箇所のインデックスを返す。ともに発見できなかった場合は、-1を返す。\begin{quote}\begin{jverbatim}>>> a = [1, 2, 3, 2, 1]>>> a.indexOf(2)    　　　　　　　// 先頭から検索1>>> a.lastIndexOf(2)    　　　　　// 後尾から検索3>>> a.indexOf(0)                  // 見つからない-1\end{jverbatim}\end{quote}ｴverb|indexOf()|とｴverb|lastIndexOf()|は、どのような配列に対しても検索が可能である。しかし、単純に順番に検索するため、検索時間は配列の大きさに比例し、効率はあまりよいといえない。もし配列がｴverb|sort()|で整列された状態であるときは、ｴverb|binarySearch()|を用いると、バイナリーサーチアルゴリズムにより効率よく検索することができる。\begin{quote}\begin{jverbatim}>>> a = [1, 3, 2, 4, 0]>>> a.sort()>>> a[0, 1, 2, 3, 4]>>> a.binarySearch(3)             // バイナリサーチ3>>> a.binarySearch(5)             // 見つからない-1\end{jverbatim}\end{quote}\section{配列とイテレーション}\section{バイト列: {\tt byte[]}}\chapter{辞書とハッシュ表}\section{辞書リテラル}\begin{quote}\begin{jverbatim}\end{jverbatim}\end{quote}\section{辞書と演算子}\begin{quote}\begin{jverbatim}\end{jverbatim}\end{quote}\section{辞書とメソッド}