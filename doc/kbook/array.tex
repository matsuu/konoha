\chapter{配列とリスト}配列(array)は、複数個のオブジェクトを扱う最も基本的なデータ構造である。Konohaでは、配列は{\sf Array}クラスとして実現されている。名前は、シンプルに{\sf Array}であるが、Javaの{\sf ArrayList} と同様に、可変長の成長する配列（Growing Array）であり、リストとしても利用できる。\section{配列と型}Konoha は、{\sf Array}型と\verb|C[]|型の、２種類のスタイルの配列が存在するようにみえる。{\sf Array}型は、任意の型の要素をもつのに対し、\verb|C[]|はある特定の{\sf C}型の要素のみもつ。しかし、両者は、ともに{\sf Array}のいわゆる総称型の別名で、つまるところ、\verb|Array<Any>|と\verb|Array<C>|である。基本的な性質は大きく変わらない。本書では、Konoha スタイルで型を書くが、実際のソースコードでは配列スタイル、総称型スタイルのどれを利用しても構わない。\begin{kshell}Konoha          配列            総称型Array           Any[]           Array<Any>           int[]           int[]           Array<int>String[]        String[]        Array<String>   C[]             C[]             Array<C>\end{kshell}注意: \verb|int[]| は、\verb|Array<int>|と同じであるとなっているが、あくまでも見かけ上の話である。Konoha 内部では、より正確に言えば、unbox された形で整数要素を格納している。同様に、\verb|float[]|もunbox された配列である。ちなみに、\verb|boolean[]|は、unboxされた配列ではない。\subsection{{\tt Any[]}と{\tt Object[]}の違い}{\sf Object} は、全てのオブジェクトの上位クラスであるため、{\tt Object[]}は{\tt Any[]}、つまり{\sf Array}と同様に任意の型のオブジェクトを要素に持つことができる。ただし、「第 \ref{dynamic_language} 章　ダイナミック言語の特徴」で述べるとおり、{\sf Object} と{\sf Any}は、キャストの取扱いが異なるため、両者には注意すべき違いが生じる。まず、{\tt Object[]}の方であるが、基本的に Java の配列と振る舞いは同じである。ただし、要素の型は、コンパイルした時点では {\sf Object}型であり、次の例のとおり、実行時の要素が {\sf String}型であっても、明示的なダウンキャストが必要となる。\begin{kshell}>>> String[] o = ["naruto", "sakura"];>>> typeof(o[0])                // 型はObjectObject>>> String s = (String)o[0];    // ダウンキャスト>>> s"naruto"\end{kshell}これに対し、{\tt Any}型は、実行時に動的な型検証が入るため、静的なキャストは不要になる。こちらの方が便利な反面、暗示的に型キャストをしているため気づかないで実行効率が落ちることがある。\begin{kshell}>>> Any[] a = ["naruto", "sakura"];>>> typeof(a[0])                // 型は動的Any>>> String s = a[0];            // キャストは不要>>> s"naruto"\end{kshell}\subsection{{\sf null}要素}Konohaの配列は、{\sf null}値を配列要素に持つことができない。ただし、{\sf Array}型({\sf Any[]})は、そもそも{\sf Any}型がnullを認めるため、{\sf null}を要素にもつことができる。\begin{kshell}>>> String[] s = ["naruto"];>>> s[0] = null;** Null!! \end{kshell}\subsection{バイト列 {\tt byte[]}}Konohaの整数型は、64ビット長の{\sf Int}型に単一化されているため、バイト(8ビット整数)を表す型はない。多少、メモリが無駄かも知れないが、{\sf int} でバイトを表すことになる。しかし、バイト列（バイナリデータ）となると、\verb|int[]|を使うのでは多少の無駄では済まない。そこで、バイト列を扱う専用のクラスとして、{\sf Bytes}が用意されている。\verb|byte[]| は、ごたぶんに漏れず、{\sf Bytes}の別名である。\begin{kshell}byte[] buf = new byte[4096];\end{kshell}バイト列 \verb|byte[]| は、配列とほぼ同じ性質を持ち、本章で取り上げるメソッドや演算子をほぼそのまま利用することができる。バイト列特有の性質のみ、「第\ref{byte_array}節 バイト列」で取り上げる。\subsection{共変性** }% covariance と contravariance という言葉は、 元々は圏論（category theory）という数学の分野の用語で、 それぞれ共変性・反変性と訳します。\section{配列の生成}配列は、配列リテラルで配列をデータとして与えるときと、コンストラクタを用いて配列を作る場合の2種類の方法がある。\subsection{配列リテラル}配列リテラルは、Python や JavaScript などで採用されている\verb|[]|コンストラクタを用いる。重要な相違点は、リストの要素によって配列の型が推論される点である。配列リテラルの型推論リールは、いたって単純である。まず、最初の要素の型 $T$を配列型 $T[]$の候補として、残りの要素がすべて $T$か、そのサブタイプであるとき、\verb|T[]|と推論する。そうでないときは、{\sf Array}クラスとなる。 \begin{kshell}[]                            // 空の Array[1,2,3]                       // Int[] の配列["Naruto", "Sakura"]          // String[]の配列["Naruto", 9]                 // Array\end{kshell}\subsection{Array コンストラクタ}{\sf Array}クラスのコンストラクタは、2種類存在する。ひとつは、{\sf Array}をリストとして利用するため、空の{\sf Array} を作る方法である。\begin{kshell}>>> a = new Array(10);        // 空のArrayを生成>>> a[]\end{kshell}もうひとつは、Java 言語と同様に、配列の大きさをあらかじめ当てはめて宣言する方法である。\begin{kshell}>>> a = new Any[4];           // 要素数n個の配列>>> a[null, null, null, null]\end{kshell}\subsection{{\tt C[]}コンストラクタ}配列のコンストラクタは、Java 言語と同様に、配列の大きさをあらかじめ当てはめて宣言する方法である。\begin{kshell}>>> ss = new String[4];        // 要素数4個の配列String[]>>> ss["", "", "", ""]\end{kshell}生成された配列の要素は、要素型のデフォルト値(\verb|default(C)|)で満たされる。(Javaと異なり、null ではない。) デフォルト値が不都合な場合は、要素数を0にして空の配列を生成したのち、追加することになる。\begin{kshell}>>> ss = new String[0];        // 空のString[]>>> ss[]\end{kshell}\section{配列と演算子}配列は、0個以上の要素が並んだ典型的なシーケンスである。Konohaでは、シーケンス s は、\verb#|s|# 演算子を用いることで、その長さを得ることができる。配列の場合は、要素の数である。\begin{kshell}>>> a = [0, 1, 2, 3]>>> |a|4\end{kshell}配列\verb|a|のインデックスは、C/C++, Java言語と同様に 0 から始まり、\verb#|a| - 1# である。その範囲を超えると、\verb|OutOfIndex!!|例外が通知される。\begin{kshell}>>> a = [0, 1, 2, 3]>>> a[0]0>>> a[|a|-1]3>>> a[4]OutOfIndex!!\end{kshell}配列は、基本的に変更可能である。正しいインデックスを指定すれば配列の値を変更できる。\begin{kshell}>>> a = [0, 1, 2, 3]>>> a[1] = 10                    // a[1]を変更>>> a[0, 10, 2, 3]\end{kshell}注意：初期のKonohaでは、python 風に最後尾からインデックスを数える $-n$ 表記が利用できた。このインデックスは便利であったが、C/C++, Java などの既存の配列処理との互換性や最適化処理の困難さを理由に廃止となった。\subsection{スライシング}配列\verb|a|から部分配列を取り出すときは、スライス演算子\verb|a[m..n]|を用いることができる。$m$と$n$は、省略可能で、省略した場合は、それぞれ0と最後の添字(\verb#|a|-1#)と解釈される。\begin{kshell}>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8]>>> a[2..]                       // a[2]から[2, 3, 4, 5, 6, 7, 8]>>> a[2..6]                      // a[2]からa[6]まで[2, 3, 4, 5, 6]>>> a[..<6]                      // a[2]からa[5]まで[2, 3, 4, 5]>>> a[2..+6]                     // a[2]から6個[2, 3, 4, 5, 6, 7]>>> a[..6]                       // a[6]まで[0, 1, 2, 3, 4, 5, 6]>>> a[..<6]                      // a[6]まで（含まない)[0, 1, 2, 3, 4, 5]>>> a[..+6]                      // 最初の6個[0, 1, 2, 3, 4, 5, 6]\end{kshell}\subsection{リストとセット {\tt in?}}\section{多次元配列}Konohaの配列は、基本的に1次元配列である。n 次元配列を使うというのは、単純に、C言語同様に適切に次元を計算してからインデックス操作を行えばよい。例えば、それぞれの次元の大きさがX, Y, Z の3次元配列を使いたい場合は、次のようにインデックス(\verb|index|)を計算できる。\begin{kshell}int[] a = new int[X * Y * Z];index = x + X * y + (X * Y) * z;a[index]\end{kshell}当初、多次元配列に関しては、これで十分だと考えていた。それは、Konoha言語の開発を含め、過去のプログラミング実践で多次元配列がなくて困った経験をほとんどしなかったためである。しかし、これもクラスルームから来た要求であるが、初期のプログラミング練習課題は、オセロやら五目並べやら、やたらと2次元配列を使いたくなることが多い。学生から、「2次元配列は使えないのですか？」と質問される度に、上記の式を書くより、シンタックスシュガーでさっさと対応すべきではないか？、ということになった。そういうわけで、多次元配列は、型としては1次元配列のときと同じである。ただし、コンストラクタで次元を設定すると、次元情報はメタデータとして記録され、このメタ情報を用いて多次元からインデックスをを再計算している。確かに、少しすっきりする。\begin{kshell}int[] a = new int[X, Y, Z];a[x, y, z]\end{kshell}注意：次元をメタ情報として管理しているため、次元数に上限が生じる。Konohaでは、最もよく使うと考えられる2次元、もしくは3次元配列のみサポートされている。4次元配列が必要なアプリケーションを書いておられる方は、是非、連絡して欲しい。\\次は、2次元配列の利用例である。クラスルームで使う程度であれば、ふつうの2次元配列として利用することができる。\begin{kshell}>>> a = new Int[8, 8];         // 2次元配列>>> a[1, 7] = 1>>> a[1, 7]1>>> a[8, 1]                    // 次元単位でチェック ** OutOfIndex!!\end{kshell}多次元配列は、1次元配列なので、1次元配列として操作することもできる。多次元配列としての型安全性は備えていない。\begin{kshell}>>> a = new Int[8, 8];         // 2次元配列>>> typeof(a)Int[]>>> |a|                        // 大きさは、1次元64>>> a.add(100)                 // 追加もできる>>> |a|65>>> a[64]                      // 1次元配列の操作も可100\end{kshell}\section{配列とメソッド}Konohaは、JavaのCollection フレームワークの標準的なメソッドをベースにして{\sf Array}関係のメソッドを定義している。\subsection{リスト: add(), insert(), remove()}Konohaの配列は、全て可変長であり、リストのように要素数のわからないデータを実行時に必要に応じて伸縮させながら利用できる。メソッド\verb|add(v)|は、最もよく使われるメソッドである。配列の最後尾に新しい要素\verb|v|を追加する。演算子 \verb|<<|と同じ働きをする。\begin{kshell}>>> a = [0, 1, 2]>>> a.add(100)　　　　　　　　　　// 追加>>> a[0, 1, 2, 100]>>> a.add(30000)                  // 追加>>> a[0, 1, 2, 100, 300000]\end{kshell}メソッド\verb|insert(n, v)|は、\verb|n|番目に要素\verb|v|を挿入するときに利用し、メソッド\verb|remove(n)|は、\verb|n|番目からを取り除くとき利用する。どちらの場合は、配列の大きさは、それぞれ増減する。\begin{kshell}>>> a = [0, 1, 2]>>> a.insert(1, 100)　　　　　　　// 挿入>>> a[0, 100, 1, 2]>>> a.remove(2)                   // 削除>>> a[0, 100, 2]\end{kshell}Konohaの配列は、リストのように利用できるが、双方向リンクリスト構造ではないため、\verb|insert(), remove()|ともに配列要素をコピーするだけのコストがかかる。\verb|add()|は、十分に高速に要素を追加することができる。\subsection{キューとスタック: first(), pop()}Konohaの配列は、キュー(FIFO)やスタック(FILO)として利用することができる。\begin{kshell}>>> queue = []>>> queue.push(1)                 // キューに追加 add()と同じ>>> v = queue.first()             // キューから取り出す\end{kshell}\begin{kshell}>>> stack = []>>> stack.push(1)                 // スタックに追加 add()と同じ>>> v = stack.pop()               // スタックから取り出す\end{kshell}注意：配列は、スタックとして利用するとき、配列の大きさに関わらず、十分に高速である。しかし、キュー操作の場合は、\verb|first()|のとき配列要素のコピーが発生するため、配列の大きさに応じてコストがかかる。\subsection{reverse(), shuffle()}Konohaは、...\begin{kshell}\end{kshell}\subsection{整列：sort()}Konohaは、高速なソートアルゴリズムによって配列の要素の並びかえることができる。大小の比較は、\verb|<| 演算子によって行われる。\begin{kshell}>>> a = [0, 2, 1]>>> a.sort()        　　　　　　　// ソート>>> a[0, 1, 2]\end{kshell}注意：\verb|sort()|は、いわゆる昇順ソートである。降順ソートのためのメソッドは用意されておらず、\verb|sort()|と\verb|reverse()|を組み合わせて用いると、降順になる。\subsection{サーチ: indexOf(), lastIndexOf(), binarySearch()}サーチは、配列中から指定された要素を探すことである。配列は、\verb|indexOf()|は、先頭から探して最初に見つかったインデックスを返す。\verb|lastIndexOf()|は、逆に最後尾から検索して最初に見つかった箇所のインデックスを返す。ともに発見できなかった場合は、-1を返す。\begin{kshell}>>> a = [1, 2, 3, 2, 1]>>> a.indexOf(2)    　　　　　　　// 先頭から検索1>>> a.lastIndexOf(2)    　　　　　// 後尾から検索3>>> a.indexOf(0)                  // 見つからない-1\end{kshell}\verb|indexOf()|と\verb|lastIndexOf()|は、どのような配列に対しても検索が可能である。しかし、単純に順番に検索するため、検索時間は配列の大きさに比例し、効率はあまりよいといえない。もし配列が\verb|sort()|で整列された状態であるときは、\verb|binarySearch()|を用いると、バイナリーサーチアルゴリズムにより効率よく検索することができる。\begin{kshell}>>> a = [1, 3, 2, 4, 0]>>> a.sort()>>> a[0, 1, 2, 3, 4]>>> a.binarySearch(3)             // バイナリサーチ3>>> a.binarySearch(5)             // 見つからない-1\end{kshell}\section{バイト配列: {\tt byte[]}}\label{byte_array}バイト配列は、バイナリデータを扱うための専用の配列であり、ヒープ上のメモリを確保し、それをダイレクトに扱うことができる。\begin{kshell}>>> buffer = new byte[4096];>>> typeof(buffer)Bytes\end{kshell}\verb|sort()|や\verb|shuffle()|など、バイナリ操作にあまり関係ないメソッドをサポートしていないが、それ以外は配列と同じように操作することができる。%\subsection{バイト配列: {\tt byte[]}}\begin{comment}\chapter{辞書とハッシュ表}\section{辞書リテラル}\begin{kshell}\end{kshell}\section{辞書と演算子}\begin{kshell}\end{kshell}\section{辞書とメソッド}\chapter{イテレーション}\end{comment}