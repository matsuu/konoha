\chapter{配列とリスト}配列(array)は、複数個のオブジェクトを扱う最も基本的なデータ構造である。Konohaでは、配列は{\sf Array}クラスとして実現されている。名前は、シンプルに{\sf Array}であるが、Javaの{\sf ArrayList} と同様に、可変長の成長する配列（Growing Array）であり、リストとしても利用できる。\section{配列と型}Konoha では、２つの種類の配列型が存在するようにみえる。ひとつは、任意の型の要素をもつ{\sf Array}型であり、もうひとつある特定の{\sf C}型の要素のみもつ\verb|C[]|である。両者は、ともに{\sf Array}のいわゆる総称型の別名で、つまるところ、\verb|Array<Any>|と\verb|Array<C>|である。基本的な性質は大きく変わらない。本書では、Konoha スタイルで型を書くが、実際のソースコードでは配列スタイル、総称型スタイルのどれを利用しても構わない。\begin{quote}\begin{jverbatim}Konoha          配列          総称型Array           Any[]         Array<Any>           int[]           int[]         Array<Int>String[]        String[]      Array<String>   C[]             C[]           Array<C>\end{jverbatim}\end{quote}注意： {\sf null} 要素に関してのみ注意が必要である。{\sf Array}型は、その要素型である{\sf Any}型がnullを認めるため、{\sf null}を要素にもつことができるのに対し、{\sf C[]}型は、{\sf null}を要素にもつことができない。\begin{quote}\begin{jverbatim}>>> String[] s = ["naruto"];>>> s[0] = null;** Null!! \end{jverbatim}\end{quote}%\subsection{型修飾子**}\subsection{共変性*}\section{配列の生成}配列は、配列リテラルで配列をデータとして与えるときと、コンストラクタを用いて配列を作る場合の2種類の方法がある。\subsection{配列リテラル}配列リテラルは、Python や JavaScript などで採用されている\verb|[]|コンストラクタを用いる。重要な違いは、リストの要素によって配列の型が推論される点である。配列リテラルの型推論リールは、いたって単純である。まず、最初の要素の型 $T$を配列型 $T[]$の候補として、残りの要素がすべて $T$か、そのサブタイプであるとき、\verb|T[]|と推論する。そうでないときは、{\sf Array}クラスとなる。 \begin{quote}\begin{jverbatim}[]                        // 空の Array[1,2,3]                   // Int[] の配列["Naruto", "Sakura"]      // String[]の配列["Naruto", 9]             // Array\end{jverbatim}\end{quote}\subsection{Array コンストラクタ}{\sf Array}クラスのコンストラクタは、2種類存在する。ひとつは、{\sf Array}をリストとして利用するため、空の{\sf Array} を作る方法である。\begin{quote}\begin{jverbatim}>>> a = new Array(10);    // 空のArrayを生成>>> a[]\end{jverbatim}\end{quote}もうひとつは、Java 言語と同様に、配列の大きさをあらかじめ当てはめて宣言する方法である。\begin{quote}\begin{jverbatim}>>> a = new Any[4];       // 要素数n個の配列>>> a[null, null, null, null]\end{jverbatim}\end{quote}\subsection{{\tt C[]}コンストラクタ}配列のコンストラクタは、Java 言語と同様に、配列の大きさをあらかじめ当てはめて宣言する方法である。\begin{quote}\begin{jverbatim}>>> ss = new String[4];        // 要素数4個の配列String[]>>> ss["", "", "", ""]\end{jverbatim}\end{quote}生成された配列の要素は、要素型のデフォルト値(\verb|default(C)|)で満たされる。(Javaと異なり、null ではない。) デフォルト値が不都合な場合は、要素数を0にして空の配列を生成したのち、追加することになる。\begin{quote}\begin{jverbatim}>>> ss = new String[0];        // 空のString[]>>> ss[]\end{jverbatim}\end{quote}\section{配列と演算子}配列は、0個以上の要素が並んだシーケンスである。Konohaでは、シーケンス s は、\verb#|s|# 演算子を用いることで、その長さを得ることができる。配列の場合は、要素の数である。\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2, 3]>>> |a|4\end{jverbatim}\end{quote}配列\verb|a|のインデックスは、C/C++, Java言語と同様に 0 から始まり、\verb#|a| - 1# である。その範囲を超えると、\verb|OutOfIndex!!|例外が通知される。\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2, 3]>>> a[0]0>>> a[|a|-1]3>>> a[4]OutOfIndex!!\end{jverbatim}\end{quote}配列は、基本的に変更可能である。正しいインデックスを指定すれば配列の値を変更できる。\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2, 3]>>> a[1] = 10>>> a[0, 10, 2, 3]\end{jverbatim}\end{quote}配列\verb|a|から部分配列を取り出すときは、スライス演算子\verb|a[m..n]|を用いることができる。$m$と$n$は、省略可能で、省略した場合は、それぞれ0と最後の添字(\verb#|a|-1#)と解釈される。\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8]>>> a[2..]                       // a[2]から[2, 3, 4, 5, 6, 7, 8]>>> a[2..6]                      // a[2]からa[6]まで[2, 3, 4, 5, 6]>>> a[..<6]                      // a[2]からa[5]まで[2, 3, 4, 5]>>> a[2..+6]                     // a[2]から6個[2, 3, 4, 5, 6, 7]>>> a[..6]                       // a[6]まで[0, 1, 2, 3, 4, 5, 6]>>> a[..<6]                      // a[6]まで（含まない)[0, 1, 2, 3, 4, 5]>>> a[..+6]                      // 最初の6個[0, 1, 2, 3, 4, 5, 6]\end{jverbatim}\end{quote}注意：初期のKonohaでは、python 風のシーケンスの最後尾からインデックスを数える $-n$ 表記が利用できた。このインデックスは便利であったが、C/C++, Java などの既存の配列との互換性（相互運用生）や最適化処理の困難さを理由に廃止となった。\section{多次元配列}Konohaの配列は、基本的に1次元配列である。配列コンストラクタのとき、2次元、もしくは3次元で配列を大きさを指定すると、2次元、3次元の情報がメタデータとして記録されて、あたかも2次元配列、3次元配列のように利用することができる。ただし、型としては1次元配列として識別している。\begin{quote}\begin{jverbatim}>>> a = new Int[10, 10];         // 2次元配列>>> a = new Int[10, 10, 10];     // 3次元配列>>> a[1, 2, 3] = 4>>> a[1, 2, 3]4>>> typeof(a)Int[]\end{jverbatim}\end{quote}\section{配列とメソッド}Konohaは、JavaのCollection フレームワークの標準的なメソッドをベースにして{\sf Array}関係のメソッドを定義している。\subsection{リスト: add(), insert(), remove()}Konohaの配列は、全て可変長であり、リストのように要素数のわからないデータを実行時に必要に応じて伸縮させながら利用できる。メソッド\verb|add(v)|は、最もよく使われるメソッドである。配列の最後尾に新しい要素\verb|v|を追加する。演算子 \verb|<<|と同じ働きをする。\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2]>>> a.add(100)　　　　　　　　　　// 追加>>> a[0, 1, 2, 100]>>> a.add(30000)                  // 追加>>> a[0, 1, 2, 100, 300000]\end{jverbatim}\end{quote}メソッド\verb|insert(n, v)|は、\verb|n|番目に要素\verb|v|を挿入するときに利用し、メソッド\verb|remove(n)|は、\verb|n|番目からを取り除くとき利用する。どちらの場合は、配列の大きさは、それぞれ増減する。\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2]>>> a.insert(1, 100)　　　　　　　// 挿入>>> a[0, 100, 1, 2]>>> a.remove(2)                   // 削除>>> a[0, 100, 2]\end{jverbatim}\end{quote}Konohaの配列は、リストのように利用できるが、純粋なリストデータではないため、\verb|insert(), remove()|ともに配列をコピーするだけのコストがかかる。\verb|add()|は、十分に高速に要素を追加することができる。\subsection{キューとスタック: first(), pop()}Konohaの配列は、キュー(FIFO)やスタック(FIFO)として利用することができる。\begin{quote}\begin{jverbatim}>>> queue = []>>> queue.add(1)                  // キューに追加>>> v = queue.first()             // キューから取り出す\end{jverbatim}\end{quote}\begin{quote}\begin{jverbatim}>>> stack = []>>> stack.add(1)                  // スタックに追加>>> v = stack.pop()               // スタックから取り出す\end{jverbatim}\end{quote}\subsection{swap(), reverse(), shuffle()}Konohaは、...\begin{quote}\begin{jverbatim}\end{jverbatim}\end{quote}\subsection{整列：sort()}Konohaは、十分に高速なソートアルゴリズムによって配列の要素の並びをソートすることができる。\begin{quote}\begin{jverbatim}>>> a = [0, 2, 1]>>> a.sort()        　　　　　　　// ソート>>> a[0, 1, 2]\end{jverbatim}\end{quote}\subsection{サーチ: indexOf(), lastIndexOf(), binarySearch()}サーチは、配列中から指定された要素を探すことである。配列は、\verb|indexOf()|は、先頭から探して最初に見つかったインデックスを返す。\verb|lastIndexOf()|は、逆に最後尾から検索して最初に見つかった箇所のインデックスを返す。ともに発見できなかった場合は、-1を返す。\begin{quote}\begin{jverbatim}>>> a = [1, 2, 3, 2, 1]>>> a.indexOf(2)    　　　　　　　// 先頭から検索1>>> a.lastIndexOf(2)    　　　　　// 後尾から検索3>>> a.indexOf(0)                  // 見つからない-1\end{jverbatim}\end{quote}\verb|indexOf()|と\verb|lastIndexOf()|は、どのような配列に対しても検索が可能である。しかし、単純に順番に検索するため、検索時間は配列の大きさに比例し、効率はあまりよいといえない。もし配列が\verb|sort()|で整列された状態であるときは、\verb|binarySearch()|を用いると、バイナリーサーチアルゴリズムにより効率よく検索することができる。\begin{quote}\begin{jverbatim}>>> a = [1, 3, 2, 4, 0]>>> a.sort()>>> a[0, 1, 2, 3, 4]>>> a.binarySearch(3)             // バイナリサーチ3>>> a.binarySearch(5)             // 見つからない-1\end{jverbatim}\end{quote}\section{配列とイテレーション}\section{バイト列: {\tt byte[]}}\chapter{辞書とハッシュ表}\section{辞書リテラル}\begin{quote}\begin{jverbatim}\end{jverbatim}\end{quote}\section{辞書と演算子}\begin{quote}\begin{jverbatim}\end{jverbatim}\end{quote}\section{辞書とメソッド}