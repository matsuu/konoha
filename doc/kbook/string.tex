\chapter{文字列}文字は、人類史の始まり以来、最も重要な情報表現の手段である。情報社会といわれる現在においても、社会や文化を支える主要な情報は、文字によって記録され、伝えられている。そのため、プログラミングにおける文字の重要性も明らかといえる。文字やテキストをうまく扱うことは、情報処理の中心的な役割を占めているからである。プログラミング言語では、文字を１文字、1文字扱うのは不便なので、複数個以上の文字の並びを「文字列 (string)」として扱う。Konohaは、文字列を表現するため、{\sf String}クラスを提供し、独自のフォーマティング機能とあわせて、自由自在な文字列操作を実現している。\section{文字列と型}ほぼ全てのプログラミング言語は、海外で生まれたという経緯もあって、長らく「文字=ASCIIコード=1バイト」という前提で開発されてきた。これが不幸の始まりで、スクリプティング言語であっても、日本語を処理する場合はどうしても１文字が何バイトに相当するか意識しながら文字列処理を強要されることが多かった。Konohaは、21世紀になってからの設計であり、Unicode 文字を採用し、1文字はそれが何バイトであっても1文字と数えている。つまり、文字列処理において、文字コードを意識しなくて済む設計になっている。文字列は、0個以上の Unicode 文字からなる。Konoha では、文字単体を扱う特別な型は存在せず、文字は長さ１の文字列として表現される。\begin{kshell}"a"                       // ASCII文字"あ"                      // Unicode 文字\end{kshell}どうしても文字コードを扱う必要があるときは、UCS4(31ビット)コードとして、{\sf Int}型を用いて扱うことができる。\begin{kshell}>>> ("a").getChar()       // ASCIIコード>>> ("あ").getChar()      // UCS4 コード\end{kshell}Konoha は、{\sf String}の内部エンコーディングとして、UTF8を利用している。本来、文字列は実装依存しない抽象化されたデータ構造であるべきであるが、UTF8以外はバイト列({\sf Bytes}/{\sf byte[]})して扱うことになる。{\sf String}から、各種エンコーディングにしたがってバイト列に変換する方法も用意されている。\begin{kshell}s.getBytes("shift_jis")  // Shift_JIS へ変換new String(byte, "shift_jis");\end{kshell}注意：入出力ストリームにはエンコーディングが設定できるようになっているため、エンコーディングを処理するケースはあまりない。n\section{文字列リテラル}プログラミング言語では、「プログラム要素の識別子」と「データとしての文字列」を区別するため、文字リテラルのルールにしたがって、文字列をデータ値として記述する。Konoha は、C/C++、Python、C\#に由来する3種類の文字列リテラル、さらに独自のリテラルもサポートしている。ここでは、これらを順番に説明する。\subsection{ダブルクオート}最も基本的な文字列リテラルは、文字列をダブルクオート(")で囲む形式である。このリテラルは、C言語を含め、ほぼ全てのプログラミング言語で広く採用されている。\begin{kshell}""                        // 空文字列"hello, world""3.14""Say \"hi.\""             // エスケープ記号"いろは"                  // Unicode 文字\end{kshell}文字列リテラルとして、そのまま表現できない文字、例えば改行や\verb|"|は、エスケープ記号(\verb|\|)を用いて記述する。Konoha は、次の6種類のエスケープシーケンスのみサポートする。\begin{kshell}sequence       Character represented\n             改行(LF)\t             タブ\\             \記号\'             'シングルクオート (""中)\"             "ダブルクオート (''中)\:             :コロン (''中)\end{kshell}\subsection{シングルクオート}Konohaでは、シングルクオート(')も、コロン(:)の扱いに注意すれば、文字列リテラルの始まりと終わりとして利用することができる。シングルクオートを用いると、ダブルクオート(")を含む文字をすっきりと表すことができる。\begin{kshell}'a'                       // "a"と同じ'Say "hi"'                // "Say \"hi.\"" と同じ'http\://'                // : はエスケープが必要\end{kshell}シングルクオートは、正式には「タグ付き文字列」のリテラルとして定義されている。タグ付き文字列とは、文字列の先頭に\verb|'tag:...'|のようなタグを付けて、文字列の意味を識別し、その意味にしたがって適切なオブジェクトを生成するリテラルである。\begin{kshell}'re:s$'                  // 正規表現(Regex)'file:/tmp/konoha.k''isbn:978-4-87311-329-6''IO!!:File Not Found'    // 例外(Exception)\end{kshell}注意：「タグ付き文字列」のタグが未定義な場合は、通常の文字列リテラルとして解釈される。ただし、明示的にタグでないことを示すためには、エスケープ(\verb|\:|)する必要がある。詳しくは、「第\ref{semantic_programming}章 セマンティックプログラミング」で述べる。\subsection{バッククオート}バッククオート(`)も、\verb|%|記号の扱いに注意すれば、文字列リテラルの始まりと終わりの記号として利用できる。こちらを用いれば、シングルクオートとダブルクオートが混在する文字列をすっきりと表すことができる。\begin{kshell}`Naruto said, "I'm a ninja."`\end{kshell}バッククオートは、正式には「インライン・フォーマッティング」、つまり文字リテラル中の書式が評価される特別な文字列リテラルとして用いられる。次は、\verb|%d{}|内の式が評価され、\verb|%d|フォーマッタで整形された文字列が埋め込まれている。\begin{kshell}>>> core =2>>> `make -j%d{core+1}`"make -j3"\end{kshell}もしバッククオートを文字リテラルとして利用するときは、\verb|%|文字は、\verb|\%|、もしくは\verb|%%|のようにエスケープ処理が必要になる。詳しくは、「第\ref{inline_formatting}節 インラインフォーマッティング」で述べる。\subsection{トリプルクオート}トリプルクオートは、Python に由来するテキスト用の文字リテラルである。''' もしくは、""" で囲まれたテキストは、改行やタブ文字もそのまま文字列として扱われる。ただし、エスケープシーケンスも有効である。\begin{kshell}'''This is a rather long string containingseveral lines of text just as you would do in C.    Note that whitespace at the beginning of the    line is significant.'''\end{kshell}また、トリプルバッククオート(```)によるインラインフォーマッティングも有効である。\begin{kshell}```configuremake -j%d{core+1}```\end{kshell}Konoha では、読みやすさを向上するため、ちょっとした改良をのトリプルクオートに加えてある。トリプルクオートの先頭が改行の場合は、その改行は無視される。したがって、上記のトリプルクオート文字列は、"c"から始まる。\subsection{RAW 文字列}RAW文字列とは、エスケープシーケンスを無視した文字列リテラルである。Konoha は、C\# に由来する記法を採用し、文字リテラルの前に@を付加するとRAW文字列として用いられる。\begin{kshell}@"C:\My Document\Programming\Konoha"\end{kshell}\subsection{行リテラル}行リテラルは、ドキュメントや他言語のスクリプトを読みやすく書くための、 Konoha 独自の拡張リテラルである。 \verb|#| で始まるトークンは、その行の終わりまでをそのまま文字列として解釈される。また、途中で、\verb|#|が入っていてもそれは文字列の一部として解釈される。ただし、\verb|#|直後の空白(スペース)だけは、読みやすさのため挿入と解釈され、それは無視される。行リテラルは、バッククオートと同じく、「インライン・フォーマッティング」を解釈する。\begin{kshell}# make -j3         　　  // "make -j3"と同じ# make -j%d{core+1}\end{kshell}行リテラルは、文字列リテラルの連結のところで述べるとおり、ドキュメントや他言語のスクリプトを（読みやすく）書くための記法である。多くのスクリプティング言語では、\verb|#|はコメントと解釈されるので、多用すると読みにくくなる。次のソースは、Konohaの文法的に正しい用例であるが、読みにくくなる。\begin{kshell}>>> s = # make -j3\end{kshell}\subsection{文字列リテラルの連結}文字列リテラルは、複数並べると、自動的に連結されてひとつの文字列となる。異なるタイプのクオートを混在させたときは、先頭のクオートタイプで連結される。\begin{kshell}"hello" "," "world"　　  // "hello,world"と同じ\end{kshell}文字列リテラルの間に改行があると、連結するとき自動的に改行を含めて、連結される。これは、行リテラルの連結のときに、特に威力を発揮する。Konohaでは、Groovy と同じく、メソッドや関数の第一パラメータに文字列リテラルを書くとき、関数コール演算子\verb|()|を省略することができる。行リテラルの連結と組み合わせて利用すると、すっきりとスクリプトが書くことが可能になる。\begin{kshell}db.query   # create table book (   #    name char[20];   #    title char[80];   # );\end{kshell}\noindent下記のソースと完全に同じである。\begin{kshell}db.query('''create table book (name char[20];title char[80];);''')\end{kshell}\section{文字列と演算子}文字列は、「文字」配列である。ただし、Konoha の{\sf String}は、不変(Immutable)オブジェクトであるため、Read Onlyの「文字」配列となる。\subsection{長さとシーケンス}文字列は、0個以上の文字が並んだシーケンスである。Konohaでは、シーケンス s は、\verb#|s|# 演算子を用いることで、その長さを得ることができる。文字列の場合、そこに含まれる文字の数である。\begin{kshell}>>> s = "";　　>>> t = "ABC"; >>> u = "ABCいろは";>>> |s|0>>> |t|3>>> |u|6\end{kshell}Konohaの文字列の長さは、多国語化された設計となっているため、文字のバイト数に関わらず、文字数が文字列の長さとなる。ASCII(1バイト)文字列を前提としたバイト数でないことに注意したい。もし文字列のバイト数をしりたい場合は、一旦、バイト配列(\verb|byte[]|)に変換すればよい。ただし、このときUTF8エンコーディングが用いられ、それにしたがい日本語は3バイト以上になっている。\begin{kshell}>>> s = "ABCいろは";>>> b = (byte[])s;>>> |b|12\end{kshell}文字列は、文字の配列として扱うことができる。配列のインデックスは、0から始まり、\verb#|s| - 1# である。\begin{kshell}>>> s = "ABCいろは";>>> s[0]"A">>> s[|s|-1]            // 最後の一文字"は"\end{kshell}注意：Konoha の文字列は、変更不能(immutable)である。通常の配列のように値を変更することができない。\\文字列から部分文字列(substring)を取り出すときは、シーケンススライス演算子を用いることができる。\begin{kshell}>>> s = "ABCいろは";>>> s[..2]"ABC">>> s[3..]"いろは">>> s[2..4]"Cいろ"\end{kshell}\subsection{連結}文字列の連結は、Java と同様に、加算(+)演算子によって書くことができる。この加算は、もちろん結合則や交換則に基づくものではないが、操作が直感的であり、広く使われている。\begin{kshell}>>> "Uzumaki" + " " + "Naruto""Uzumaki Naruto"\end{kshell}Konoha は、文字列の加算を最も優先されるオペレータとして定義している。つまり、文字列と文字列以外のオブジェクトを混在して換算した場合、全て文字列に変換されたのち連結される。\begin{kshell}>>> "Naruto " + 8 + 1            // %s(8) + %s(1)と同じ"Naruto 81"\end{kshell}もし数値演算を優先したい場合は、括弧()で囲んで先に計算する。\begin{kshell}>>> "Naruto " + (8 + 1)          // %s(8 + 1)と同じ"Naruto 9"\end{kshell}\subsection{連結、除去、分割}Konohaでは、加算に加えて、減算、乗算、除算の演算子にもそれぞれ各演算子の意味に近い文字列操作として定義されている。これらも数学的な性質は継承しないが、文字列処理としてときに便利である。文字列の減算 \verb|s - t| は、文字列 s から指定された文字列 t を取り除く操作である。これは、\verb|s.replace(t, "")|に相当する。\begin{kshell}>>> "Uzumaki Naruto" - "a" - "u";"Uzmki, Nrto"\end{kshell}文字列の乗算\verb|s * n|は、文字列の四則演算の中で唯一整数値を引数にとる。しかし、そこから得られる結果は極めて直感的に、文字列s を n個連結したものである。\begin{kshell}>>> "Naruto" * 3;"NarutoNarutoNaruto">>> "hello" * 0""\end{kshell}文字列の除算\verb|s / t|は、文字列 s を文字列tで分割したときの先頭の文字列である。文字列の余算\verb|s % t|は、分割された残りの文字列となる。これは、\verb|s.split(t)|の簡易版として利用される。\begin{kshell}>>> "Uzumaki Naruto" / " ""Uzumaki">>> "Uzumaki Naruto" % " "            // mod のこと"Naruto"\end{kshell}\subsection{文字列の比較}文字列は、関係演算子によって比較することができる。そのとき、単純にアルファベットオーダー(UTF8 のコード順)で比較され、英大文字/英小文字は無視されない。\begin{kshell}>>> "Uzumaki" == "Naruto"false>>> "Uzumaki" > "Naruto"ture\end{kshell}\section{文字列メソッド}Konohaは、Java言語に由来する{\sf String}メソッド を標準的にサポートし、更により多くの文字列操作メソッドも拡張している。本節でとりあげるメソッドは、その一部である。しかし、本節のメソッドだけで、Konohaプロジェクトで利用しているドメイン言語(DSL)とCソースコード生成器を作成することができる。%\subsection{equals()}\subsection{startsWith(), endsWith()}Konoha は、正規表現によるパターンマッチングが利用できるが、多くの場合、文字列の先頭、もしくは末尾のみマッチングするだけで事足りることが多い。メソッド\verb|s.startsWith(t)|は、文字列 \verb|s|の先頭が文字列\verb|t|と一致するか判定するときに利用できる。逆に、メソッド\verb|s.endsWith(t)|は、文字列 \verb|s|の末尾が文字列\verb|t|と一致するか判定できる。\begin{kshell}>>> s = "Uzumaki Naruto">>> s.startsWith("Uzumaki")true>>> s.startsWith("Naruto")false>>> s.endsWith("Uzumaki")false>>> s.endsWith("Naruto")true\end{kshell}\verb|startsWith()|と\verb|endsWith()|は、英大文字/小文字を区別する。\verb|equals()|と同様にIgnoreCaseバージョンを利用すれば、英大文字/英小文字を無視してマッチングを行うことができる。\begin{kshell}>>> s = "Uzumaki Naruto">>> s.startsWith("uzumaki")false>>> s.startsWith:IgnoreCase("uzumaki")true\end{kshell}\subsection{検索: indexOf(), lastIndexOf()}\verb|index()|系の文字列操作は、C言語の標準ライブラリから存在する古典的な文字列ライブラリである。Konohaでは、Java同様に、文字でなく、部分文字列の検索ができる。メソッド\verb|s.indexOf(t)|は、文字列 \verb|s|の先頭から部分文字列\verb|t|を探し、その位置を返すメソッドである。逆に、メソッド\verb|s.lastIndexOf(t)|は、文字列 \verb|s|の末尾から部分文字列\verb|t|を探し、その位置を返すメソッドである。位置は、文字列のインデックスと同様に0から始まる。ともに、部分文字列\verb|t|を発見できなかった場合は、\verb|-1| を返す。\begin{kshell}>>> s = "Uzumaki Naruto">>> s.indexOf("Naruto")>>> s.indexOf("Sakura")-1>>> s.indexOf("a")4>>> s.lastIndexOf("a")9\end{kshell}最もよく使う利用法は、シーケンススライスと組み合わせて、文字列を分割するときである。\begin{kshell}>>> s = "Name: Uzumaki Naruto">>> s[.. s.indexOf(": ")]"Name">>> s[s.indexOf(": ")+1 ..].trim()"Uzumaki Naruto"\end{kshell}\subsection{split(), tokenize()}メソッド\verb|s.split(t)|は、文字列 \verb|s|を分割文字列\verb|t|によって単純に分割するメソッドである。分割された文字列は、\verb|String[]|に格納される。（分割文字列\verb|t|)は、含まれない。）\begin{kshell}>>> s = "Naruto, Sakura, Sasuke">>> s.split(", ")["Naruto", "Sakura", "Sasuke"]>>> s.split(",")["Naruto", " Sakura", " Sasuke"]\end{kshell}特別な用例としては、分割文字列を省略すると、文字列は1文字ずつsplit()される。\begin{kshell}>>> s = "naruto">>> s.split()["n", "a", "r", "u", "t", "o"]\end{kshell}もう少し意味のある単位でトークンを分割したい場合は、メソッド\verb|s.tokenize()|も利用できる。これは、文字列 \verb|s|を Konoha のレキシカル構造にしたがってトークンに分割するメソッドである。\begin{kshell}>>> s = '''print (1+1), 'hello,world';'''>>> s.tokenize()["print", "(", "1", "+", "1", ")",    ",", "'hello,world'", ";"]\end{kshell}\subsection{置換: replace()}メソッド\verb|s.replace(t, u)|は、文字列 \verb|s|中に出現する部分文字列\verb|t|を与えられた文字列\verb|u|によって置き換えるメソッドである。Konohaでは、文字列は不変オブジェクトであり、破壊的操作はできないため、新しいString オブジェクトが生成され、メソッドの戻り値として返される。\begin{kshell}>>> s = "Haruno Naruto">>> t = s.replace("Haruno", "Uzumaki")>>> t"Uzumaki Naruto">>> s                             // 元の文字列は変わらない"Haruno Naruto"\end{kshell}注意：\verb|replace()|メソッドは、正規表現パターンによる置き換えも可能である。詳しくは、「第\ref{regular_expression}節 正規表現」で述べる。\subsection{toUpper(), toLower()}メソッド\verb|s.toUpper()|は、文字列 \verb|s|の英文字を英大文字に変換し、メソッド\verb|s.toUpper()|は、文字列 \verb|s|の英文字を英小文字に変換するメソッドである。\begin{kshell}>>> s = "Uzumaki Naruto">>> s.toUpper()"UZUMAKI NARUTO">>> s.toLower()"uzumaki naruto"\end{kshell}\subsection{メソッドのパッケージ拡張}Konoha は、実行中であってもクラスに新しいメソッドを追加したり、既存の振る舞いを変更することができる。{\sf String} クラスも例外ではなく、パッケージのインポートによって、メソッドが拡張されることがある。\begin{kshell}>>> using japanese;                 // 日本語パッケージ>>> ("なると").toKatakana()           // カタカナへの変換"ナルト">>> ("ナルト　").trim()             // 全角空白も除去される"ナルト"\end{kshell}\section{テンプレート・フォーマッティング}フォーマッタは、オブジェクトを様々な書式で文字列化するKonoha独自の機能である。理想的には、全てのオブジェクトはクラス階層にしたがってフォーマッタが定義され、全てのフォーマッティングはオブジェクト指向モデルによってよく再利用されるべきである。しかし、現実問題としては、再利用性を考慮に入れるよりも、とりあえずアドホックなフォーマッティングが便利なケースも多い。その場合、従来のテンプレート・フォーマッティング、つまり「テンプレートを作成しテンプレートの変数を置き換えることでフォーマッティングを行う」ことは、便利である。Konohaでは、ビルトイン関数 \verb|format()|を用いることで、テンプレートとそのパラメータを組み合わせてフォーマットされた文字列を生成することができる。もちろん、Konohaでは、全フォーマッタをテンプレートの書式として利用することができる。\begin{kshell}>>> format("We are at [%s:%d]:", __file__, __line__)"We are at [(shell):1]"\end{kshell}テンプレートは、テンプレート書式にしたがえば、あとは通常の文字列として扱うことができる。次は、変数に格納されたテンプレートをフォーマット処理したときである。\begin{kshell}>>> fmt = "We are at [%s:%d]:";>>> s = format(fmt, __file__, __line__)>>> s"We are at [(shell):4]"\end{kshell}\subsection{テンプレートの書式}テンプレート書式は、\verb|"%x{n}"|スタイルで、「フォーマッタ\verb|%x|に n 番目のパラメータを適用する」と意味になる。ここでインデックスは、1 から始まる。わざわざ、パラメータのインデックスを指定できる理由は、英語と日本語のような語順が違うテンプレートでも、パラメータの順番を気にしなくて適用するためである。\begin{kshell}>>> fmt = """... print "name";... print "name"... """\end{kshell}\subsection{フォーマッティング}テンプレートは、ビルトイン関数 \verb|format()|を用いて、フォーマッティングされる。フォーマットされた文字列は、関数の戻り値として返される。\begin{kshell}>>> format(fmt, n, n)\end{kshell}フォーマッティング時のパラメータは、Konohaにおいて数少ないコンパイル時に型検査されないパートである。フォーマッタは、与えられたパラメータのクラスに対して、動的にバインドされる。もし指定されたフォーマッタが定義されてなければ、自動的に \verb|%empty|が適用され、そこには文字列が表示されない。もし厳密な型検査を求める場合は、関数等でラッピングして用いるとよい。\section{インライン・フォーマッティング}\label{inline_formatting}Konoha では、\verb|#|で始まるライン文字列リテラルに対してのみ、インデックスの代わりに、変数やその他の式を直接埋め込むことができる、ダイレクトフォーマッティングを認めている。\begin{kshell}c.query    # select name, salary from persontbl   # where age > %d{age} and age < %d{age2}\end{kshell}\section{正規表現}\label{regular_expression}正規表現(regular expression) は、文字列のパターンを記述する小さな言語であり、有限オートマトンにコンパイルされ、強力なマッチングエンジンとあわせて利用されることが多い。スクリプティング言語では、Perl を代表例として文字列処理の中心的機能として正規表現を言語に統合している。Konoha では、独自の「正規表現」という概念は存在しないが、GNU regex, Oniguruma, PCRE(Perl Compatible Regular Expression) など、既存の正規表現ライブラリを選択して利用することができる。\subsection{正規表現リテラル}正規表現パターンは、{\sf Regex} クラスのインスタンスとして表現される。Konohaでは、Perl, Ruby, JavaScript などと同様に、専用の正規表現リテラルが用意されている。正規表現リテラルは、\verb|/|記号で囲まれた文字列であり、そこで表現された文字列は正規表現パターンと解釈される。\begin{kshell}pattern = /s$/\end{kshell}正規表現リテラルは、{\sf Regex}コンストラクタで生成されるオブジェクトと全く同じである。また、Regex コンストラクタは、@Const 属性であるため、コンパイル時にオブジェクトが生成されるため、性能の面でも同じである。しかし、正規表現リテラルの方を使うことが圧倒的に多い。何よりもシンプルに記述できるからである。特別なオプションを指定するときだけ、現在のところ、コンストラクタを使う必要がある。\begin{kshell}pattern = new Regex("s$", "i");         // 英大文字/小文字を無視..\end{kshell}\subsection{正規表現エンジン}Konoha は、標準的な正規表現エンジンとして、POSIX regex ライブラリを利用することが多い。現在の正規表現エンジンは、\verb|$konoha.regex| で確認することができる。\begin{kshell}>>> $konoha.regex"GNU regex library"\end{kshell}正規表現エンジンは、正規表現パッケージをインポートすることで切り替えることができる。主な正規表現パッケージは、以下のとおりである。\begin{itemize}\item {\sf oniguruma} --- kosako 氏が開発し、Ruby で正式採用されている高性能な正規表現ライブラリ\item {\sf pcre} --- Perl 互換の正規表現ライブラリ\end{itemize}切り換えは、パッケージのインポートと同期している。つまり、正規表現パッケージをインポートすれば、正規表現ドライバが入れ替えられ、それ以降の正規表現は新しいエンジンに切り替わる。\begin{kshell}>>> using oniguruma;>>> $konoha.regex"oniguruma">>> pattern = /^*.:*.$/          // 以後は、鬼車を利用\end{kshell}注意：正規表現ライブラリをインポートする以前の正規表現オブジェクトは更新が反映されない。\\また、正規表現ライブラリごとの異なる機能を明示的に使い分けたいときは、正規表現リテラルの代わりに、\verb|'regex:'|、\verb|'pcre:'|、\verb|'onig:'| のように、それぞれのライブラリを識別する意味タグを用いることで、正規表現を用いることができる。\begin{kshell}>>> using oniguruma;>>> s =~ 'onig:^*.:*.$'; 　　　　// 鬼車でマッチング>>> s =~ 'regex:^*.:*.$';        // regexでマッチング\end{kshell}\subsection{正規表現と演算子}Konoha は、Perl 由来の正規表現マッチング演算子をサポートしている。しかし、JavaScriptもサポートしていないようだから、この演算子は中止しようかと悩んでいる。\begin{kshell}>>> s = "name: naruto";>>> s =~ /^*.: *.$/true\end{kshell}\subsection{正規表現とメソッド}{\sf String} クラスは、いくつかのメソッドを正規表現パターンに対応させている。\verb|s.serach(p)|は、文字列\verb|s|の先頭から、正規表現パターン\verb|p|でマッチング検索を行い、最初にマッチした文字列インデックスを返す。\verb|indexOf()|の正規表現版である。\begin{kshell}>>> text.search(/ha/);\end{kshell}\verb|s.match(p)|は、文字列\verb|s|に対して、正規表現パターン\verb|p|でマッチングを行い、そのマッチング結果の文字列を返す。複数個マッチした場合は、全て返す。\begin{kshell}>>> s = "1 + 2 = 3";>>> s.match(/\d/);["1", "2", "3"]\end{kshell}また、正規表現パターンにおいてグルーピングを用いれば、マッチングした文字列に続いて、グルーピングされた部分文字列も得ることできる。\begin{kshell}>>> url = "http://www.website.org/konoha";>>> url.match(/(\w+):\/\/([\w.]+)\/(\S*)/);["http://www.website.org/konoha",    "http", "www.website.org", "konoha"]\end{kshell}%\verb|s.split(p)|では、分割文字列の代わりに、正規表現パターン\verb|p|を用いて分割することができる。\verb|s.replace(p, fmt)|は、文字列\verb|s|に対して、正規表現パターン\verb|p|でマッチングを行い、その結果をフォーマッティング\verb|fmt|によって置き換える演算子である。\begin{kshell}>>> s = "1 + 2 = 3";>>> s.replace(/(\d)/, "%s{1}.0");"1.0 + 2.0 = 3.0"\end{kshell}\subsection{正規表現とマッピング**}最近のPerl互換の正規表現では、名前付きのグルーピングを提供している。文字列を正規表現からパースして、直接オブジェクトへマッピングする機能を計画している。\begin{kshell}>>> Class Url {...   String site;...   String path;... }>>> url = "http://www.website.org/konoha";>>> pattern = /(\w+):\/\/(?site:[\w.]+)\/(?path:\S*)/;>>> u = (Url with pattern)url;　　　// 何言語だ？>>> u{site: "www.website.org", path: "/kohoha"}\end{kshell}