\chapter{Konohaの特徴}Konoha は、「Java 風の文法をもった静的に型付けされたスクリプティング言語」である。しかし、１行で表現できる以上の新しさを備えている。本章は、Konoha の特徴を簡単なソースコードとともに紹介したいと思う。\section{おなじみの言語文法}Konoha の文法は、C/C++ や Java と高い互換性をもっている。これは、はじめてプログラミングを学ぶ者にとって、C/C++, Java などのメインストリーム言語の良き導入になるだけでなく、経験あるプログラマにとって特別な努力を費やすことなく、Konoha プログラミングがはじめられることを意味する。次は、Konoha によるfibonacci 数列を再帰で求める関数である。もちろん、C/C++, Java でも、そのまま動作する。\begin{quote}\begin{jverbatim}int fibo(int n) {	if(n < 3) return 1;	return fibo(n-1)+fibo(n-2);}\end{jverbatim}\end{quote}これが一方、Perl や Python, Ruby, Lua, さらに例え、Java風の文法をもったJavaScript であっても、いきなり初見で fibonacci 関数を書ける人はいないだろう。必ず文法の細かな違いが存在し、脇に置かれた参考書をたよりにしなければならない。Konohaが、従来のJavaスタイルのスクリプティング言語と比べても、高い互換性をもっているのは、それはJavaと同じく静的に型付けされている点が大きい。これによって、オブジェクト指向プログラミングも、よりJavaに近いモデリング手法でクラスを設計することができる。\begin{quote}\begin{jverbatim}class Counter {	int _count;	Counter(int n) { _count = n; }	void count() { _count++; }}\end{jverbatim}\end{quote}ただし、Konoha は、独立したプログラミング言語である。あくまでもC/C++やJavaプログラマが文法の差異によって生じる混乱を最小限にとどめるために、文法の互換性をとっている。そのため、スクリプティング言語として、簡略化されている部分もあるし、独自に拡張されている文法もある。\section{対話的な動作: Looks like Java, Runs like Python}Konohaプロジェクトのキックオフ当時の目標は、"Looks like Java, Runs like Python"、つまり「Javaのように書けてPythonのように実行できる」であった。現在、Konohaは、Python のみならず、Ruby や JavaScriptなど、様々なスクリティング言語の設計を参照しながら開発を行っているが、Konohaのスクリプティング言語としてのお師匠は、Python なのである。Python へのオマージュが最もよくあらわれている部分が、対話モードである。{\sf konoha }を実行すると、対話モードが起動する。\begin{quote}\begin{jverbatim}$ konohaKonoha 0.3.10 (Rufy) GPL2 (#544, May  2 2009, 09:37:22)[GCC 4.0.1 (Apple Inc. build 5490)] on macosx_32 (32, UTF-8)Options: iconv sqlite3 thread regex used_memory:412 kb>>> \end{jverbatim}\end{quote}\verb|>>>| は、コマンドプロンプトである。複数行にわたる場合は、2行目以降は、\verb|...| となる。ここにプログラム（式もしくはステートメント）を入力すると、次の行にはその実行結果が得られる。\begin{quote}\begin{jverbatim}>>> print "hello, world"hello, world\end{jverbatim}\end{quote}Konoha の対話モードは、Lisp の対話的プログラミングほど、それ自体で成り立つプログラミング環境ではない。しかし、Konohaの機能、動作を試したいとき、十分に役立つ機能である。次は、\verb|fibo()| 関数を対話モードで定義し、その場で実行したときの様子である。\begin{quote}\begin{jverbatim}>>> int fibo(int n) {...	  if(n < 3) return 1;...	  return fibo(n-1)+fibo(n-2);... }>>> fibo(36)55\end{jverbatim}\end{quote}\section{型推論}Konohaの特徴は、静的な型付けである。これは、ごく一般的に言えば、変数の型宣言をプログラマに強制することを意味する。ダイナミック言語に親しんできたプログラマには、この強制はちょっと面倒な制約に見えてしまうだろう。\begin{quote}\begin{jverbatim}int n = 1;                                // 変数宣言\end{jverbatim}\end{quote}念のため補足しておけば、静的な型付けは、プログラミングモジュールの仕様を明示的に定義することであり、大規模なソフトウェア開発やグループ開発において、ケアレスミスや誤解によるソフトウェアクラッシュを防ぐ重要な機能である。Konoha がスクリプティング言語であっても、静的に型付けされているのは悪い話ではない。しかし、慣習とは恐ろしいもので変数宣言なしでいきなり変数を使いたくなることもある。\begin{quote}\begin{jverbatim}n = 1;                                    // 変数宣言なし\end{jverbatim}\end{quote}Konohaは、非常に限定的であるが、実用的に十分な型推論(type inferencing)の機構を備え、明示的に変数宣言をしなくても、その変数の型を推論する機能を備えている。これは、変数宣言なしであっても、変数の初期化の値からその変数の型を推論する機能である。\begin{quote}\begin{jverbatim}>>> a = [1,2,3]                    // 推論による型宣言>>> n = a[1]>>> typeof(a)                       // 静的な型付けを調べるInt[]>>> typeof(n)Int\end{jverbatim}\end{quote}Konohaの型推論は、プログラミングのしやすさと型宣言による厳密な仕様定義の間で、バランスをとりながら設計されている。また、型を推論できなかった場合、{\sf Any}型による動的な型付けのオプションも用意され、ダイナミック言語の特性を活かしたプログラミングを可能である。\begin{quote}\begin{jverbatim}>>> s = null;                          // 型推論できない>>> typeof(s)Any\end{jverbatim}\end{quote}{\sf Any} 型やダイナミック言語の特性を活かしたプログラミングは、「第 \ref{dynamic_style} ダイナミック・スタイル」でより詳しく解説する。\section{最速水準の実行性能}スクリプティング言語は、元来、プログラムの実行速度より、プログラムの開発速度に重きをおいてきた。実行性能を比べるだけであれば、C/C++やJava言語の足下にも及ばない。しかし、より複雑なアプリケーション開発にもスクリプティング言語が利用されるようになった現在、スクリプティング言語エンジンの性能向上は大きな関心事になっている。Konoha は、バイトコード型バーチャルマシンで実装されたスクリプティング言語エンジンをもっている。スクリプトは、バイトコードにコンパイルされ、そしてバーチャルマシン上で実行される。そして、このとき、Konoha は静的な型付けの特性を活かして、より効率のよいコードを生成することができる。\verb|fibo()|関数をフォーマッタ機能でダンプすると、実際にコンパイル済みのバイトコードをみることができる。\begin{quote}\begin{small}\begin{jverbatim}>>> %dump(Script.fibo)int main.Script.fibo(int n) [4:0x2038e0] SETESP(30) sfp[2] [4:0x2038e8] iLTn(99) sfp[2] sfp[1] 3 [4:0x2038fc] bJIFF(62) 0x20391c sfp[2] [4:0x203910] RETo(35) sfp[-1] 1 [5:0x20391c] iSUBn(87) sfp[5] sfp[1] 1 [5:0x203930] FCALL(46) sfp[3] 3 sfp[0] int main.Script.fibo(int n) [5:0x203940] iSUBn(87) sfp[6] sfp[1] 2 [5:0x203954] FCALL(46) sfp[4] 3 sfp[0] int main.Script.fibo(int n) [5:0x203964] iADD(84) sfp[-1] sfp[3] sfp[4] [5:0x203970] RET(32)\end{jverbatim}\end{small}\end{quote}現在、10年以上にわたる高速化チューニングが施されたPython や世界最速のスクリプティング言語 Lua と比べ、同等以上の実行性能を示している。ここで注意してもらいたいのは、Konoha は大学の研究室から生まれたプログラミング言語であり、そもそも大学の教員も学生も本職のソフトウェア開発者に比べると実装スキルには大きな限界がある。それを差し引いてもなお、好成績を示しているのは、Konoha は、従来のダイナミック言語の設計に比べ、原理的に高速化に適した言語構造を採用しているためである。\section{実行前の型検査といつでも実行}型検査とは、型に対する操作、例えば関数コールのとき引数の数やその種類が間違っていないか、確認することである。ダイナミック言語は、実行時にのみ型検査が行われるため、型エラーが含まれるスクリプトを実行したとき、型エラーが発見される。そのため、実行しながらひとつひとつ型エラーを探し、修正する必要がある。（全実行パスをテスト実行してみて、型エラーを全て取り除くことができる。）Konohaは、スタティック言語の特性を活かして、スクリプトの実行前に全て型検査を一度に行うことができる。konoha スクリプトを実行するとき、\verb|-c| オプションを追加すれば、型エラーや潜在的なミスに対する誤りを全て検査して表示することができる。このとき、実際にプログラムを走らせることはないため、ファイルやデータベースが中途半端な状態でストップする心配もない。\begin{quote}\begin{jverbatim}$ konoha -c sample/helloworld.k\end{jverbatim}\end{quote}Konohaは、従来のスタティック言語と異なり、型エラーが発見されても、スクリプトを実行することができる。これは、Konoha言語において開発された"run anytime"コンパイル技術により、発見された型エラーの部分のみ、実行しても安全なコード（ランタイム例外）に書き換えることで、実行可能なバイトコードを生成するからである。Konohaは、とりあえずプログラムを動かすため、エラーの発生する箇所をコメントアウトしたり、スタブコードを作る必要なく、いつでもダイナミック言語のように動作させることが可能である。もしエラー箇所を実行したときは、\verb|Source!!|例外が通知されて停止する。\begin{quote}\begin{jverbatim}$ konoha sample/helloworld.k\end{jverbatim}\end{quote}\section{オブジェクト指向}Konoha は、「全てがオブジェクト」という世界観で統一されたオブジェクト指向プログラミング言語である。整数も {\sf null}もオブジェクトで表現されている。また、最先端のオブジェクト指向プログラミングのアイディアと技法を体験するため、\begin{itemize}\item 名前ベースのクラスシステム\item 単一継承、インターフェースによるポリモーフィズム\item ダックタイピングによるポリモーフィズム\item 総称型（Generics) \item メタオブジェクト、アスペクト指向\item データ変換と相互運用性（Mappable Class) \end{itemize}\subsection{クラスを調べる}オブジェクト指向プログラミング言語は、各クラスにその機能性(capability)が集約されている。Konoha では、対話モードから {\sf man} コマンドで使えば、クラスが提供するオペレーションが表示される。\begin{quote}\begin{jverbatim}>>> man IntCLASSNAME	konoha.Int	extends konoha.NumberCONST	Int.MAX: 9223372036854775807	Int.MIN: -9223372036854775808OPERATOR	        -x      x != x       x & y       x * y       x + y  	     x - y       x / y       x < y      x << y      x <= y  	    x == y       x > y      x >= y      x >> y       x ^ y  	   x mod y       x | y         x++         x--         |x|  	        ~x  METHOD	Int! Int.random(Int n)FORMATTER	%bits %d %f %s %u %x MAPPING	Int		==> Float		==> String\end{jverbatim}\end{quote}Konoha は、実行時にメソッド等を追加できる。{\sf man} コマンドは、実行時の状態を表示するため、メソッドの種類は変更になる。\section{オブジェクト指向フォーマッタ}Web時代になって、より多くの情報はHTML, XML などある種のフォーマット化されたテキストで表現されている。テキストフォーマッティングは、主要なプログラミングタスクのひとつであるが、今なおオブジェクト指向プログラミングの再利用性の恩恵を享受できない分野として残っている。Javaは、例えば、\verb|toString()|メソッドを用いて、任意のオブジェクトを文字列表現に変換できたが、様々なフォーマット出力を切り替えることはできない。Konoha は、オブジェクト指向機能のひとつとして書式付きフォーマッタを提供している。フォーマッタは、C 言語のprintf風の書式 (\verb|%s, %d|) に似ているが、オブジェクトと書式は出力時にダイナミックバインドされる。つまり、C言語では型に対して書式が決まっていたのに対し、Konoha では{\sf int}型でも小数形式で出力したいときは\verb|%f|を用いることができる。\begin{quote}\begin{jverbatim}>>> %s(1)1>>> %03d(1)001>>> %f(1)1.00000>>> %bits(1)00000000 00000000 00000000 00000001\end{jverbatim}\end{quote}また、フォーマッタはメソッドの一種として、プログラマが自由に定義することが可能であり、\verb|%HTML|のような複雑なフォーマッタも作成できる。フォーマッタは、単純にメモリ上の文字列に変換するだけでなく、ストリームへの直接出力も可能であり、大量のデータを低メモリ消費で変換することができる。\section{マッピング機能とデータ変換*}Konoha の最大のオブジェクト指向モデルの拡張は、異種データベース翻訳や軽量オントロジ技術をベースにした高度なマッピング機能を導入した点にある。つまり、簡単にいえば、全ての変換操作はキャスト演算に統合され、データ変換のためのメソッド/関数名を覚える負担から解放される。\begin{quote}\begin{jverbatim}>>> (String)1"1">>> (Int[])1[1]\end{jverbatim}\end{quote}Konoha は、マッピング意味論を厳密に形式化管理し、複雑なマッピングを自動生成するマッピング推論エンジンを備えている。（以下つづく）\section{セマンティック・プログラミング*}