%\chapter{システムとコンテキスト}%\section{言語処理系}%\section{ガベージ・コレクション}%\section{オペレーティングシステム}%\subsection{バーチャル変数 os}%\begin{quote}%\begin{jverbatim}%%\end{jverbatim}%\end{quote}%\section{環境変数}%\section{コンテキスト Context}%\section{プロパティ変数}\chapter{ストリーム}{\sf InputStream} は入力ストリーム、{\sf OutputStream}は出力ストリームをそれぞれバイトシーケンスとして抽象化したクラスである。ストリームは、種類によるが、原則的にメモリの上限を気にすることなく、バイトデータの読み書きが可能である。また、バイト配列({¥tt byte[]})とは異なりランダムアクセスできず、読み込み({\sf InputStream})もしくは書き込み({\sf OutputStream})操作のどちらか、シーケンシャルにサポートするのみである。Konohaの{\sf InputStream}と{\sf OutputStream}は、C言語由来の低水準APIをメソッドをサポートしている。同時に、文字列のエンコーディングを変換しながら入出力する高水準APIもメソッドとしてサポートしている。%入出力ストリームは、歴史も長いよく抽象化されたデータ構造である。様々なリソースとの情報のやりとりを、バイト列のストリームとして抽象化して扱うことができる。Konoha では、C言語レベルのコンポジットパターンでストリームの種類を抽象化し、{\sf InputStream} と {\sf OutputStream}の２つのクラスから様々な種類のストリームを扱うことを可能にしている。%として利用することができる。伝統的なオブジェクト指向クラス設計では、これらのクラスを階層構造で設計する。例えば、Java は、{\sf InputStream} クラスを抽象クラスとして、{\sf FileInputStream}, {\sf ByteArrayInputStream}, {\sf SocketInputStream}などのサブクラスでストリームの種類が実現している。%{\sf InputStream} は入力ストリーム、{\sf OutputStream}は出力ストリームをそれぞれバイトシーケンスとして抽象化したクラスである。ストリームの種類に寄るが、原則的にメモリの上限を気にすることなく、バイト列の読み書きが可能である。また、バイト列とは異なりランダムアクセスできず、読み込み({\sf InputStream})もしくは書き込み({\sf OutputStream})操作のどちらかのみサポートすることになる。\section{標準ストリーム}Konohaは、システム定数 \verb|IN|, \verb|OUT|, \verb|ERR| を通して、標準入力(stdin)、標準出力(stdout), 標準出力(stderr)にそれぞれ相当する各種ストリームオブジェクトが得られる。\begin{quote}\begin{jverbatim}>>> OUT"/dev/stdout">>> OUT.println("hi");hi\end{jverbatim}\end{quote}また、それぞれのストリームのデフォルト値として、"/dev/null"に相当するストリームを持っている。これらは、何のデータも読み込めないし、何のデータも書き込めない特別なストリームである。\begin{quote}\begin{jverbatim}>>> out = default(OutputStream);>>> out"/dev/null">>> out.println("hi");             // 何も出力されない>>> \end{jverbatim}\end{quote}\subsection{生成}新しいストリームは、{\sf InputStream}もしくは{\sf OutputStream}クラスのコンストラクタにリソース名を与えて生成する。何らかの理由でストリームが生成できない場合は、\verb|IO!!|例外がスローされる。\begin{quote}\begin{jverbatim}in = new InputStream("file.txt");foreach(String line from in) {	print line;}in.close()\end{jverbatim}\end{quote}入力ストリームの種類は、リソース名から自動的に判断される。Konoha は、下記のリソース以外にもストリームドライバーをインストールすることで、種類を拡張することができる。\begin{itemize}\item{\bf ファイル} --- ファイルパス（ファイル名）を与えるし、もしくは明示的に\verb|file:|タグをリソース名の先頭につける。\item{\bf WEBリソース} --- URLを与える。ちなみに、これは \verb|http:| タグで始まるリソース名となっている。\end{itemize}また、文字列やバイト列など、内部リソース(メモリ）をストリームとして抽象化する扱うこともできる。これは、マップキャスト演算子を用いて入力ストリームを得ることで生成する。\begin{quote}\begin{jverbatim}>>> String data = "naruto";>>> in = (InputStream)data;>>> in.getc();\end{jverbatim}\end{quote}注意：文字列は、UTF8でエンコーディングされたバイトストリームとして扱われる。\subsection{データの読み込み}入力ストリームは、バイト列である。バイトは、Konoha では、0から255までの整数で表現される。{\sf InputStream} クラスは、C言語に由来する低水準な読み込みメソッドを備えている。ひとつは、1バイトずつ読み込む \verb|getc()|メソッドである。正しくストリームから読めた場合は、0~255 の値を返すか、もしストリームの終端に達した場合は、EOF を返す。\begin{quote}\begin{jverbatim}>>> InputStream in;>>> while(ch = in.getc() != EOF) {...   OUT << %c(ch);... }\end{jverbatim}\end{quote}もうひとつは、\verb|read()|メソッドで、バッファ({\sf byte[]})へ指定された指定されたバッファサイズ(\verb|buf|)分を一度に読み込むことができる。戻り値は、実際に読み込まれたサイズであり、0からバッファサイズまでのどれかの値となる。\begin{quote}\begin{jverbatim}>>> InputStream in;    >>> byte[] buf = new byte[4096];>>> while((in.read(buf) != 0) {...   OUT << buf;... }\end{jverbatim}\end{quote}\subsection{テキストの読み込み}\subsection{入力ストリームの終了}\section{{\sf OutputStream} 出力ストリーム}\section{ファイル}\section{パイプ}パイプは、プロセス間通信の最もシンプルで広く使われている方法です。Konoha では、UNIX(互換)パッケージを用いることで、{\sf InputStream} か {\sf OutputStream} のどちらをパイプに連結することができます。パイプを識別するタグは、\verb|'pipe:'|, \verb|'sh:'|, \verb|'cmd:'| のどれかです。\subsection{外部プログラムからデータを受ける}パイプが最も活躍するシチュエーションは、外部のコマンド（プログラム）を起動し、その実行結果をえるときです。次は、UNIX コマンド(ls)を実行し、その実行結果を1行ずつ表示するスクリプトの例です。Windows の場合は、ls コマンドがないので、代わりに dir で試してみましょう。\begin{quote}\begin{jverbatim}using unix.*;in = new InputStream("pipe:ls -l");foreach(line from in) {  print line;}in.close()\end{jverbatim}\end{quote}\subsection{外部プログラムへデータを送信する}パイプでは、{\sf InputStream} の代わりに、{\sf OutputStream}を用いれば、ストリームをとしてデータの送信が可能になります。\begin{comment}パイプが最も活躍するシチュエーションは、外部のコマンド（プログラム）を起動し、その実行結果をえるときです。次は、UNIX コマンド(ls)を実行し、その実行結果を1行ずつ表示するスクリプトの例です。Windows の場合は、ls コマンドがないので、代わりに dir で試してみましょう。\begin{quote}\begin{jverbatim}using unix.*;in = new InputStream("pipe:ls -l");foreach(line from in) {  print line;}in.close()\end{jverbatim}\end{quote}\end{comment}\section{Socket}