%¥chapter{システムとコンテキスト}%¥section{言語処理系}%¥section{ガベージ・コレクション}%¥section{オペレーティングシステム}%¥subsection{バーチャル変数 os}%¥begin{quote}%¥begin{jverbatim}%%¥end{jverbatim}%¥end{quote}%¥section{環境変数}%¥section{コンテキスト Context}%¥section{プロパティ変数}¥chapter{ストリーム}ストリームは、バイトデータの読み書きをシーケンシャル（順序通り）に行うデータ構造である。読み書きされたバイトデータは、ファイルやソケットであり、外部プログラムとの間を送受信される。Konoha では、入力ストリームと出力ストリームをそれぞれ読み込み、書き込み専用のストリームとして分離し、InputStreamクラスとOutputStreamクラスとして提供している。% さて、文字コードの問題が少々あらわれる。Konohaの InputStreamと OutputStreamは、C言語由来の低水準APIをメソッドをサポートしている。同時に、文字列のエンコーディングを変換しながら入出力する高水準APIもメソッドとしてサポートしている。¥section{標準ストリーム}Konohaは、システム定数 ¥verb|IN|, ¥verb|OUT|, ¥verb|ERR| を通して、標準入力(stdin)、標準出力(stdout), 標準出力(stderr)にそれぞれ相当する各種ストリームオブジェクトが得られる。¥begin{quote}¥begin{jverbatim}>>> OUT"/dev/stdout">>> OUT.println("hi");hi¥end{jverbatim}¥end{quote}また、それぞれのストリームのデフォルト値として、¥verb|"/dev/null"|に相当するストリームを持っている。これらは、何のデータも読み込めないし、何のデータも書き込めない特別なストリームである。¥begin{quote}¥begin{jverbatim}>>> out = default(OutputStream);>>> out"/dev/null">>> out.println("hi");             // 何も出力されない>>> ¥end{jverbatim}¥end{quote}¥subsection{生成}新しいストリームは、InputStreamもしくはOutputStreamクラスのコンストラクタにリソース名を与えて生成する。何らかの理由でストリームが生成できない場合は、¥verb|IO!!|例外がスローされる。¥begin{quote}¥begin{jverbatim}in = new InputStream("file.txt");foreach(String line from in) {	print line;}in.close()¥end{jverbatim}¥end{quote}入力ストリームの種類は、リソース名から自動的に判断される。Konoha は、下記のリソース以外にもストリームドライバーをインストールすることで、種類を拡張することができる。¥begin{itemize}¥item{¥bf ファイル} --- ファイルパス（ファイル名）を与えるし、もしくは明示的に¥verb|file:|タグをリソース名の先頭につける。¥item{¥bf WEBリソース} --- URLを与える。ちなみに、これは ¥verb|http:| タグで始まるリソース名となっている。¥end{itemize}また、文字列やバイト列など、内部リソース(メモリ）をストリームとして抽象化する扱うこともできる。これは、マップキャスト演算子を用いて入力ストリームを得ることで生成する。¥begin{quote}¥begin{jverbatim}>>> String data = "naruto";>>> in = (InputStream)data;>>> in.getc();¥end{jverbatim}¥end{quote}注意：文字列は、UTF8でエンコーディングされたバイトストリームとして扱われる。¥subsection{データの読み込み}入力ストリームは、バイト列である。バイトは、Konoha では、0から255までの整数で表現される。InputStreamクラスは、C言語に由来する低水準な読み込みメソッドを備えている。ひとつは、1バイトずつ読み込む ¥verb|getc()|メソッドである。正しくストリームから読めた場合は、0~255 の値を返すか、もしストリームの終端に達した場合は、EOF を返す。¥begin{quote}¥begin{jverbatim}>>> InputStream in;>>> while(ch = in.getc() != EOF) {...   OUT << %c(ch);... }¥end{jverbatim}¥end{quote}もうひとつは、¥verb|read()|メソッドで、バッファ({¥sf byte[]})へ指定された指定されたバッファサイズ(¥verb|buf|)分を一度に読み込むことができる。戻り値は、実際に読み込まれたサイズであり、0からバッファサイズまでのどれかの値となる。¥begin{quote}¥begin{jverbatim}>>> InputStream in;    >>> byte[] buf = new byte[4096];>>> while((in.read(buf) != 0) {...   OUT << buf;... }¥end{jverbatim}¥end{quote}¥subsection{テキストの読み込み}¥subsection{入力ストリームの終了}¥section{{¥sf OutputStream} 出力ストリーム}¥section{ファイル}¥section{パイプ}パイプは、プロセス間通信の最もシンプルで広く使われている方法です。Konoha では、UNIX(互換)パッケージを用いることで、InputStreamか OutputStreamのどちらをパイプに連結することができます。パイプを識別するタグは、¥verb|'pipe:'|, ¥verb|'sh:'|, ¥verb|'cmd:'| のどれかです。¥subsection{外部プログラムからデータを受ける}パイプが最も活躍するシチュエーションは、外部のコマンド（プログラム）を起動し、その実行結果をえるときです。次は、UNIX コマンド(ls)を実行し、その実行結果を1行ずつ表示するスクリプトの例です。Windows の場合は、ls コマンドがないので、代わりに dir で試してみましょう。¥begin{quote}¥begin{jverbatim}using unix.*;in = new InputStream("pipe:ls -l");foreach(line from in) {  print line;}in.close()¥end{jverbatim}¥end{quote}¥subsection{外部プログラムへデータを送信する}パイプでは、InputStreamの代わりに、OutputStreamを用いれば、ストリームをとしてデータの送信が可能になります。¥begin{comment}パイプが最も活躍するシチュエーションは、外部のコマンド（プログラム）を起動し、その実行結果をえるときです。次は、UNIX コマンド(ls)を実行し、その実行結果を1行ずつ表示するスクリプトの例です。Windows の場合は、ls コマンドがないので、代わりに dir で試してみましょう。¥begin{quote}¥begin{jverbatim}using unix.*;in = new InputStream("pipe:ls -l");foreach(line from in) {  print line;}in.close()¥end{jverbatim}¥end{quote}¥end{comment}¥section{Socket}