\chapter{オペレータ}オペレータとは、1つ以上の式を結びつけて評価する機構である。\verb|+|や\verb|=|などの演算子と呼び直した方がわかりやすいだろう。近代的なオブジェクト指向プログラミング言語は、ほとんどのオペレータはメソッドの一部として実現し、それをシンタックスシュガー（糖衣構文）として使いやすく提供している。本章では、Konoha が提供するオペレータの全体像を知るため、一般的な紹介を行う。オペレータは、ある特定のクラスや機能と密接に関係したものも多いが、それらは後に続く章において個々に詳説される。\section{代入演算子}代入演算子は、変数 x に 右辺式 y を評価した結果を代入(格納)する演算子である。\begin{ksource}x = y                       // y の評価値をxに代入する\end{ksource}左辺値\verb|x|となりうる値は、変数、プロパティ変数、フィールド、配列や辞書に限られる。定数は、未定義の場合に限り、定数値を定義するために代入することができる。次は、代入可能な右辺値の例である。\begin{ksource}name = "naruto"$name = "naruto"p.name = "naruto"p[0] = "naruto"   p["name"] = "naruto"P = "naruto"                // 定数は、1回のみ代入可能\end{ksource}\subsection{代入式の代入*}Konohaでは、代入演算自体も式として扱うことができる。つまり、代入 \verb|x = y| の評価値は、(代入後の) x となる。したがって、次のように、同じ値を複数の変数へ代入することも可能となる。\begin{kshell}>>> y = 2>>> x = y = 1               // x には、(y = 1) の値が代入>>> x1>>> y1\end{kshell}\subsection{多値セレクタ**}データ構造から部分的な値を切り出すことは多い。これらのプログラムを簡単に書くため、多値代入を値のセレクタとして利用する拡張計画がある。\begin{kshell}>>> s = ["naruto", "sakura"]>>> a, b = s;>>> a                      // s[0] と同じ (s.opFirst())"naruto">>> b                      // s[1] と同じ (s.opSecond())"sakura"\end{kshell}\section{コール演算子}コール演算子\verb|()|は、メソッド/関数 \verb|f|、コンストラクタ\verb|new C|、もしくはフォーマッタ\verb|%f|に続いて用いられ、メソッド/関数を呼び出すときに用いる。括弧\verb|()|の中には、0個以上のパラメータ/引数を\verb|,|で区切って与えることができる。コール演算子の評価値は、メソッド/関数の戻り値となる。(ただし、メソッド/関数の戻り値void 型の場合は、評価値はない。)\begin{ksource}f()                        // 関数 f()のコールo.f()                      // o のメソッドf()をコールnew C()                    // クラスCのコンストラクタ%f(o)                      // o のフォーマッティング\end{ksource}コール演算子で与えられるパラメータは、メソッド/関数ごとに個別に定義されている。定義と異なるパラメータでコールしようとしたときは、型エラーとなる。\begin{kshell}>>> fibo(10)55>>> Math.abs(-1)1.000000\end{kshell}\subsection{コール演算子の省略}コール演算子は、パラメータの数が１個であり、かつそれが文字リテラルである場合のみ、括弧\verb|()|自体を省略することもできる。次は、\verb|c.query("""...""")|と同じであるが、省略した方がすっきりとする。\begin{kshell}>>> c.query """select name, salary from PERSON_TBL  where age > 45 and age < 65;"""\end{kshell}\section{アドレス演算子}アドレス演算子は、変数 x の値が格納されているアドレスを返す。ただし、Konoha はポインタ演算をサポートしていないため、この機能は完全にクラスルーム目的で導入されている。\begin{ksource}&x                        // x のアドレス\end{ksource}Konohaは、ポインタ型をサポートしていないため、アドレス演算子の演算結果は、int 型である。\verb|%p|フォーマッタを使えば、アドレスとして表示される。\begin{kshell}>>> s = "hello, world">>> %p(&s)00000000\end{kshell}\section{比較演算子}%The comparators are defined for all objects. If two of objects are not comparable it will throw an exception. 比較演算子は、二つの値 x, y を比較するとき用いられ、評価結果は、論理値の{\sf true} か {\sf false} である。\begin{ksource}x == y                    // 等しいか？x != y                    // 等しくないか？x < y                     // より小さいか？x <= y                    // 以下か？x > y                     // より大きいか？x >= y                    // 以上か？\end{ksource}Konohaでは、全ての型において、x, y の比較が可能である。これは常に意味のある比較となることを保証しない。特に、x と y の型が異なる場合、かつ概念的にも比較が意味をなさない場合は、オブジェクトID（アドレス値）の比較が返される。どちらにしても、比較演算の評価値は、一意となる。\begin{kshell}>>> 1 < 2.0               // 整数と浮動小数点は比較可能true>>> 1 == "1"              // 比較不可能な型false\end{kshell}\subsection{マッチング演算子}マッチング演算子は、Perl に由来し、主に正規表現と文字列のマッチングに用いられる。\begin{ksource}x =~ y                    // xは、パターンyと等しいか？\end{ksource}マッチング演算子は、\verb|==|と異なり、対称ではない。パターンは、必ず右辺に与える必要がある。\begin{kshell}>>> s = "hello, world">>> s =~ /w.*d/true\end{kshell}\subsection{{\tt instanceof} 演算子*}{\tt instanceof} 演算子は、Java に由来し、x がクラスCのインスタンスであるか判定する。Konohaは、純オブジェクト指向言語であり、全ての値は何らかのクラスのインスタンスである。そのため、任意のxに対して、{\tt instanceof} を用いることができる。\begin{ksource}x instaceof T            // x は、Tのインスタンスか？\end{ksource}整数 {\tt 1} は、{\sf Float}のインスタンスではないが、{\sf Number}のインスタンスである。{\tt instanceof} 演算子は、次のようにテストできる。\begin{kshell}>>> 1 instanceof Floatfalse>>> 1 instanceof Numbertrue\end{kshell}また、null はどのクラスのインスタンスでないため、常に {\tt instanceof} 演算子の結果は、{\sf false} となる。ただし、{\sf Any}型のみ {\sf true}となる。\begin{kshell}>>> null instanceof Objectfalse>>> null instanceof Anytrue\end{kshell}\section{論理演算子}論理演算子は、論理式（評価結果が論理値となる式）を論理的に連結し、より複雑な論理式を作る演算子である。\begin{ksource}x && y                    // x かつ y がtrueのときx || y                    // x または y がtrueのとき!(y)                      // x がfalse のとき x and y                   // x && y と同じx or y                    // x || y と同じnot y                     // !(x) と同じ\end{ksource}Konoha の論理演算子は、C/C++, Java互換の記法と、Python 由来の記法の両方をサポートしている。どちらを使っても構わないが、C/C++, Java との互換性を重んじるなら、\verb|&&|, \verb#||#, \verb|!|を用いる方が無難である。\begin{kshell}>>> a = 1>>> b = 2>>> a == 1 && b == 2true>>> a == b || a < btrue>>> !(a == b)true\end{kshell}論理演算を混在したとき、\verb|!|, \verb|&&|, \verb#||# の順に演算される。ただし、\verb|()|で囲まれた式は優先的に評価される。論理式を混在させるときは、読みやすさのため、\verb|()|で明示的に優先する論理式を与えるのがよい。\begin{kshell}>>> a = 1>>> b = 3>>> !(a == 1) && b == 3 || a < btrue>>> !(a == 1) || b == 3 && a < bfalse>>> (!(a == 1) || b == 3) && a < btrue\end{kshell}\subsection{条件演算子}条件演算子は、条件によって評価する式を切り替える演算子である。Konoha は、次の2種類の条件演算子をサポートしている。\begin{ksource}x ? y : z                 // xがtrueのときy、そうでなければzx ?? y                    // xがnullのときy\end{ksource}演算子 \verb|x ? y : z| は、3項演算子とも呼ばれ、条件式\verb|x|の評価結果によって、式\verb|y| か 式\verb|z|が評価される。3項演算子は、読みにくくなるので、各式の周りは\verb|()|で囲んだ方がよい。\begin{kshell}>>> a = 1; b = -1;>>> a = (a < b) ? (a) : (b);>>> a-1\end{kshell}演算子 \verb|x ?? y| は、C\#で導入された null 検査用の条件演算子である。意味は、\verb|(x != null) ? x : y| と同じである。ただし、null 検査を連続するときは、こちらの方がはるかに読みやすい。\begin{kshell}>>> name = student["name"] ?? ninja["name"] ?? "unknown";\end{kshell}\section{算術演算子}% The arithmetic operators (+ - * / %) are defined for all numeric types, such as Int and Float.算術演算子は、2つの数値 x, y に対し、四則演算を行うときに用いられる。また、文字列など一部のクラスには算術演算子は、連結や分離などの意味で定義されていることもある。\begin{ksource}x + y                     // 加算x - y                     // 減算x * y                     // 乗算x / y                     // 除算x % y                     // 余り（モジュロ）x mod y                   // x % y と同じ\end{ksource}モジュロ演算子 \verb|%| は、C/C++, Javaで広く採用されているが、Konoha ではフォーマッタ名と区別しにくいので、{\tt mod} を使うか、演算子の前後に明示的に空白を入れることが推奨されている。算術演算子は、四則演算の優先順位にしたがって評価される。つまり、乗算(\verb|*|)と除算(\verb|/|)の優先度は、乗算(\verb|+|)と除算(\verb|-|)より高く、同じ優先度の場合は左から順番に評価される。評価順序を変更する場合は、先に評価したい式を括弧\verb|()|で囲めばよい。\begin{kshell}>>> 1 + 2 * 37>>> 1 + 2 - 3 * 4 / 2-3>>> (1 + 2) * 39\end{kshell}\subsection{算術代入}算術代入は、代入演算子と算術演算子を組み合わせたシンタックスシュガーである。\begin{ksource}x += y                    // x = x + yx -= y                    // x = x - yx *= y                    // x = x * yx /= y                    // x = x / y\end{ksource}算術代入は、代入可能な右辺値であれば、全て適用することができる。\begin{kshell}>>> a = [0, 1]>>> a[0] += 1              // a[0] = a[0] + 1 と同じ>>> a[1, 1]\end{kshell}ただし、\verb|a[n++] += 1|のような副作用が生じる場合は、期待通りの算術代入にはならない。\subsection{インクリメントとデクリメント}Konoha は、"Everything is an Object" の世界で、Int オブジェクトは Immutable なので、本来の意味でインクリメントとデクリメントをサポートできない。しかし、あまりに利用者からの要望が多いため、シンタックスシュガーで対応している。現在のところ、前置、後置演算の区別はない。\begin{ksource}x++                       // x = x.opNext()++x                       // x = x.opNext()x--                       // x = x.opPrev()--x                       // x = x.opPrev()\end{ksource}Konohaでは、インクリメント/デクリメント演算子は、ステートメントとして利用することを推奨している。式として利用した場合、その評価順序は、将来にわたって保証されない。\begin{kshell}>>> for(i = 0; i < 3; i++) print i;i=0i=1i=2\end{kshell}\section{ビット演算子}Konohaは、Cスタイルのビット演算子をInt型に対してサポートしている。スクリプティング言語において、これらの演算子を多用することは稀であり、これらは教育用を主目的\footnote{バーチャルマシンにおいて専用命令としてチューニングされないと意味である。}として用意されている。\begin{ksource}~x                        // ビット反転x & y                     // 論理積x | y                     // 論理和x ^ y                     // 排他論理和(XOR)x << y                    // 左シフトx >> y                    // 右シフト\end{ksource}フォーマッタ\verb|%bits| は、ビット演算子の結果を表示するとき利用できる。\begin{kshell}>>> %bits(~0)11111111 11111111 11111111 11111111>>> %bits(1 << 2)00000000 00000000 00000000 00000100\end{kshell}\section{シーケンス演算子}%Konoha supports several convenient operators for sequence/set objects, such as Array, byte[], HashMap, HashSet, DictMap, and DictSet. Konoha は、シーケンス（順序を保って並んだ集合）に対して、その操作に関する一連の演算子を提供し、それらを総称してシーケンス演算子と呼ぶ。代表的なシーケンスの例は、{\sf Array}, {\tt byte[]}, {\sf String}などがある。\begin{ksource}|s|                       // シーケンス s のサイズs[n]                      // n番目の値 s[n] = x                  // n番目に値xをセットするs[] = x                   // 全部に値xをセットするx in? s                   // s に xが含まれているか？s << x                    // s への x の追加\end{ksource}シーケンス演算子では、シーケンスの要素の種類によらず、シーケンスのインデックス\verb|n|に対して、常に $0 \le n < \verb#|s|#$が保証される。(ただし、{\sf DictMap}や{\sf HashMap}のように、インデックスの代わりにキーを用いる場合はこの限りでない。)\begin{kshell}>>> a = [0, 1, 2, 3]>>> |a|4>>> a[1]1\end{kshell}\subsection{インデックスの範囲}インデックス\verb|n|が最大値\verb#|s|#を超えた場合は、\verb|OutOfIndex!!|例外となる。古いKonoha では、Python と同様に、最後尾から数えてインデックスし直していたが、配列の境界チェックの最適化を考慮に入れて、負のインデックスは見送られた。\begin{kshell}>>> a[-1] ** OutOfIndex!!: \end{kshell}\subsection{シーケンスへの追加}演算子 \verb|<<|は、特別なシーケンス演算子であり、複数の要素を連続して追加することもできる。\begin{kshell}>>> a = [1]>>> a << 2 << 3 << 5 << 7;>>> a[1, 2, 3, 5, 7]\end{kshell}\section{スライシング演算子}スライシング演算子は、シーケンスから部分シーケンスを取り出す演算子である。Python のスライシング演算子とよく似ているが、Konoha では部分シーケンスの定義の仕方が3種類用意されている。\begin{ksource}s[x..y]                   // x番目からy番目(含む)までs[x..<y]                  // x番目からy番目まで                          //  s[x..(y-1)] と同じ s[x..+y]                  // x番目からy個の部分                          //  s[x..(x+y)] と同じ \end{ksource}文字列は、シーケンスの一種であり、スライシングで部分文字列を得ることができる。\begin{kshell}>>> s = "konoha">>> s[2..3]"no">>> s[2..<3]"n">>> s[2..+3]"noh"\end{kshell}よく似た演算子が3種類存在する理由は、これらはよく混同されて間違えるためである。逆に、３種類、範囲除外(\verb|..<|)やオフセット(\verb|..+|)をイメージしやすい演算子を導入することで、どれかを正しく使いやすくなる。また、スライシング\verb|s[x..y]|の範囲 \verb|x y|は、それぞれ省略可能である。省略したときは、それぞれ \verb|x = 0|, \verb#y = |s| - 1#が初期値として採用される。\begin{kshell}>>> s = "konoha">>> s[2..]"noha">>> s[..4]"kono">>> s[..]                  // シーケンスのコピー"konoha"\end{kshell}\section{キャスト演算子}Konoha は、オブジェクト間のデータ変換や意味変換を強力にサポートするマッピング機能を独自に導入している。これらは、C/C++, Java 言語でおなじみのキャスト演算子に統合され、利用可能である。\begin{ksource}(T)x                      // xの型Tへの変換（キャスト）x to? T                   // xは型Tへ変換可能か？\end{ksource}マップキャスト演算子\verb|(T)x|は、ソース型\verb|typeof(x)|とターゲット型\verb|T|の関係で動作が異なる。サブタイプの関係が成り立つ場合は、通常どおり、アップキャスト、もしくはダウンキャストされる。それ以外の場合は、マッパーが検索され、それが評価される。\begin{kshell}>>> Object o = "123";>>> s = (String)o;                  // ダウンキャスト>>> n = (int)o;                     // マップキャスト>>> n123\end{kshell}また、マッピングが定義されていない場合、つまりキャストができない場合は、\verb|ClassCast!!|例外となる。\begin{kshell}>>> (int)true ** ClassCast!!: Boolean ==> Int\end{kshell}これらの演算子は、マッピング機能を応用して実現されている。詳しくは、「第\ref{mapping}章 マッピング機能とデータ変換」で述べる。\section{イテレータ演算子*}イテレータ演算子は、オブジェクトから(標準)イテレータを得るときに用いる。{\sf foreach} 文において、イテレータを生成するときに用いる（内部）演算子であるが、プログラマが用いても構わない。\begin{ksource}x..                       // x の(標準)イテレータ\end{ksource}次の例では、整数配列\verb|Int[]|からイテレータ(\verb|Int..|)を得ている。\begin{kshell}>>> a = [0, 1, 2]>>> typeof(a..)>>> a..123\end{kshell}イテレータ型や標準イテレータの定義は、「第\ref{iteration}章 イテレーション」で詳しく述べる。\section{セマンティック演算子**}Konoha は、オブジェクト指向モデルの軽量オントロジ拡張を行い、クラスやオブジェクト間の意味的な関係を比較することができる。\begin{ksource}x isa? y                  // x は、y か？ IS-A 関係 x === y                   // x と y は意味的に等しいか？\end{ksource}Konohaは、文字列や数値に意味タグを付加することができる。次は、華氏(32.0F)と摂氏(0.0C)の比較である。\begin{kshell}>>> Float:F temp = 32.0F;>>> temp == 0.0C;false>>> temp === 0.0C;true\end{kshell}これらの演算子は、マッピング機能を応用して実現されている。詳しくは、「第\ref{chapter:semanticprogramming}章 セマンティックプログラミング」で述べる。\chapter{ステートメント}%A Konoha program is simply a collection of statements. This section describes the various statements in Konoha and explains their syntax. If you are familiar with C, C++, and Java, you will notice that the statements in Konoha are very similar, and you'll be able to skim this section quickly. プログラムは、ステートメントの集まりである。本章では、Konoha の基本的なステートメントとその文法を説明する。あらかじめ断っておきたいが、Konoha は C/C++, Java とステートメントレベルでの互換性を目標として設計されている。そのため、本章で紹介するステートメントは、（頑張ってかいた割には悲しい事実であるが、）経験豊富なプログラマには読み飛ばしても差し支えない内容である。なお、ステートメントの一般的な訳語は、「文」である。本来、ステートメントに統一すべきかも知れないが、{\sf if} ステートメントと呼ぶのは冗長な気がするので、広く慣習的に用いられている「{\sf if}文」的な呼称を用いている。\section{式によるステートメント}%The simplest kinds of statements in Konoha are expressions that change a program status. Assignment statements are one major category of expression statements. For example:もっとも簡単なステートメントは、プログラムの状態を変更する式(expression)である。代入式は、もっともよく使われるステートメントである。\begin{ksource}s = "Hello " + name;i *= 3;\end{ksource}%The increment and decrement operators, ++ and --, are related to assignment statements. インクリメント演算式(++)、デクリメント演算式(--)は、代入式の一種であるが、Konoha ではステートメントとして利用することができる。\begin{ksource}counter++;\end{ksource}%Function/method calls are another major category of expression statements. For example:関数/メソッドのコールも、もうひとつの代表的な式によるステートメントである。\begin{ksource}System.out.println("hello,world");Math.sin(0.5);\end{ksource}上記以外の任意の式もステートメントとして用いることができる。しかし、プログラムの状態を変更しない式は、コンパイラによって無視され、実際には評価されない。\begin{ksource}if(a == 1) print a;a + 1;                      // 無視されるreturn a;\end{ksource}%Before proceeding next, recall that statements in Konoha are separated from each other with semicolons. It is a good idea to get in the habit of using semicolons everywhere.\section{ブロック}\index{block@block}% Konoha has a way to combine a number of statements into a single statement, or statement block. This is done simply by enclosing any number of statements with curly braces. (ステートメント)ブロックは、0個以上のステートメントまとめてひとつのステートメントとして扱えるようにする。これは、任意のプログラムを中括弧 \verb|{ }|で囲むことで作ることができる。ブロックの終端には、C時代からの慣習的にセミコロン(;)は必要ない。また、ブロック内では、読みやすさのためインデントするのがよい。\begin{ksource}{   x = Math.PI;   a = Math.cos(x);   print a;}\end{ksource}注意：Konoha では、メソッド(関数)内同一スコープであるため、ブロックの中で宣言した変数はブロック外でも有効になる。詳しくは、「第 \ref{function} 章 関数」で述べられる。%Note that although this statement block acts as a single statement, it does not necessary end with a semicolon. The elemental statements within the block end in semicolons, but the block itself does not.\subsection{空ステートメント}空ステートメントは、何もしないステートメントである。ブロックを用いて空ステートメントを表すことができる。\begin{ksource}{}\end{ksource}\section{変数の型宣言}\index{かたせんげん@型宣言}Konoha の変数は、静的に型付けされている。プログラマは、新しい変数を使うとき、型宣言が必要となる。C/C++やJavaと同様、次の構文で変数$name$の型$T$を宣言することができる。\begin{quote}$T$ \verb| | $name$;\end{quote}また、変数宣言では、必要に応じて、代入演算子によって変数の初期値を与えることもできる。また同じ型であれば、複数の変数をひとつのステートメントで宣言できる。\begin{ksource}String s;                          // 初期値なしString t = "hello,world";          // 初期値ありString u, v = "ABC";               // 同じ型の複数の変数宣言\end{ksource}\subsection{クラスと型}Konoha は、オブジェクト指向プログラミング言語であるため、全ての宣言されたクラス{\sf C}を「{\sf C}」型として利用することができる。また、クラス名{\sf C}に修飾子を付けることで、その型の{\sf null}値の扱いを変更したり、配列型やイテレータ型の短縮名も利用することができる。\begin{ksource}C                      C 型 C?                     @Nullable C C!                     @NonNull C C[]                    C の配列型C..                    C のイテレータ型\end{ksource}Konoha の大きな特徴は、型に\verb|@Nullable|または\verb|@NonNull|を修飾できることである。これらは、名前が示すとおり、変数の値として{\sf null}値を認めるかどうかであるか、を制約を付加したものである。Java との大きな違いは、何も修飾しなければ、原則として NonNull型となる点である。この場合、変数宣言の初期値は、{\sf null} ではなく、そのクラスのデフォルト値となる。\begin{kshell}>>> String s;                    // 初期値のデフォルト値>>> s"">>> s = null                     // Null例外が発生 ** Null!! \end{kshell}注意：各クラス{\sf C}のデフォルト値は、組み込み関数 \verb|default(C)|を用いて得ることができる。また、デフォルト値の中には Nullオブジェクトパターンにしたがって、{\sf null} 値のように振る舞う値もある。逆に、C\#風に\verb|?|を型名に付けるか、@Nullable修飾子を用いれば、{\sf null} を保持可能な変数となる。この場合の初期値は、{\sf null} である。\begin{kshell}>>> String? t;                   // 初期値はnull>>> tnull\end{kshell}\subsection{{\sf var} 文*}{\sf var} 文は、JavaScript など一部のスクリプティング言語で採用されている変数宣言のための特別なステートメントである。Konoha では、静的に型付けして型宣言を行うため、{\sf var} 文では初期値から型推論を行い、静的な型付けを行っている。\begin{ksource}var i;                             // Any 型（型推論なし)var s = "hello,world";             // s は、String 型var x = Math.cos(0.75);            // x は、Float 型\end{ksource}注意：{\sf var} 文は省略可能である。始めての使用する変数への代入は、型推論による変数宣言とみなされる。詳細は、「第\ref{dynamic} 章 ダイナミック・スタイル」で解説する。\section{{\sf if/else} 文}\index{if@if文}%6.3   if%The if statement is the fundamental control statement that allows Konoha to execute statements conditionally. This statement has two forms. The first is:{\sf if} 文は、もっとも基本的な制御ステートメントである。与えられた条件式に応じて、続いて実行するステートメントの切り替えるときに使用する。{\sf if} 文には、2種類の形式がある。次は、簡単な形式である。\begin{quote}\verb|if| ($expr$) $stmt$\end{quote}%In this form, the expression is first evaluated. If the resulting value is true, then statement is executed. If expression is false, statement is not executed. For example:この形式では、条件式$expr$がまず評価される。その結果が、{\sf true}であれば、それに続くステートメント$stmt$が実行される。もし条件式の結果が{\sf false}であれば、ステートメント$stmt$は実行されない。\begin{kshell}>>> n = 4>>> if (n mod 2 == 0) print "even";even\end{kshell}%As mentioned in the previous section, you can always replace a single statement with a statement block.  {\sf if} 文に続くステートメントとして、ブロックを用いることもできる。ブロックを用いれば、0個以上のステートメントを順次実行することもできる。\begin{kshell}>>> if (n mod 2 == 0) {...    print "even";... }even\end{kshell}%The indention used in these examples is not mandatory. Using line breaks and indention as shown here makes the code easier to read and understand. %The second form of the if statement introduces an else clause that is executed when expression is false. Its syntax is:\subsection{{\sf else}節}\index{else@else節}{\sf if}文に続く{\sf else}節は、別のステートメントを与えるときに利用する。\begin{quote}\verb|if| ($expr$) $stmt1$ \verb|else| $stmt2$\end{quote}%In this form of the statement, expression is evaluated, and if it is true, statement1 is executed; otherwise, statement2 is executed. For example:この形式の{\sf if}文では、まず条件式$expr$が評価され、もしそれが{\sf true}であればステートメント$stmt1$が実行され、そうでなければ$stmt2$が実行される。\begin{kshell}>>> n = 3>>> if (n mod 2 == 0) {...    print "even";... } else {...    print "odd";... }odd\end{kshell}\subsection{{\sf else if}}{\sf if/else}文は、2つのステートメントの実行を分岐させることができた。更に、{\sf if/else}文を組み合わせ、あたかも {\sf else if} 文のように用いると、3つ以上の条件分岐をすっきりと書くことができる。\begin{ksource}if(n == 1) {  // n が1のとき}else if(n == 2) {  // n が2のとき}else if(n == 3) {  // n が3のとき}else {   // それ以外のとき}\end{ksource}{\sf else if}文は、特別なステートメントではなく、ふつうの{\sf if/else}文の組み合わせたに過ぎない。条件式は、上から、つまり\verb|(n == 1)|から、順番に評価されていくため、後に続く条件判定のステートメントほど処理時間が遅くなる。\section{{\sf switch} 文**}\index{switch@switch文}%6.4   switch%The switch statement is not supported in the version 0.5 of Konoha.{\sf switch} 文は、多重ディスパッチを行うための専用のステートメントである。文法は、C/C++ や Java と同様に次のとおりである。式$expr$の評価結果にマッチする{\sf case} 節が選択され、そのステートメントが実行される。\begin{quote}\verb|switch| ($expr$) \verb|{| \\\verb|   case | $c_1$ \verb| : | $stmt_1$; \\\verb|   case | $c_2$ \verb| : | $stmt_2$; \\\verb|   ... |\\\verb|   case | $c_n$ \verb| : | $stmt_n$; \\\verb|   default :|  $stmt$; \\\verb|}|\end{quote}{\sf switch}文を用いると、一般に　{\sf if/else}文よりもすっきりと複雑な条件分岐をかくことができる。次は、{\sf else if} の節で用いた多重分岐の {\sf switch} バージョンである。注意すべき点は、{\sf break}文である。これは、各 {\sf case}節は、条件分岐の始まりを表すに過ぎず、明示的に分岐の終端を表している。\begin{ksource}switch(n) {  case 1 :     // n が 1のとき  break;  case 2 :     // n が 2のとき  break;  case 3 :     // n が 3のとき  break;  default:   // それ以外のとき}\end{ksource}Konoha と C/Java との違いは、{\sf case} 節のマッチングにある。C や Java は、{\sf case}節では整数リテラルのみマッチングする条件として与えることができたが、Konoha では任意のリテラルを与えることができる。（ただし、式は与えることができない。）\begin{ksource}switch(lang) {  case "perl" :   case "python" :     //   break;  case "cpp" :     //   break;  default:   // それ以外のとき}\end{ksource}注意：この辺りが悩みどころで、コードディスパッチの最適化ができなくなるので、{\sf switch}文の実装は済んでいない。\section{{\sf while} 文}\index{while@while文}% The while loops repeatedly execute a statement block while its condition expression is true.%6.5   while%The while statement is the basic statement that allows Konoha to perform repetitive actions. It has the following syntax:{\sf while}文は、あるステートメントを繰り返し実行させる基本的なステートメントである。ループの制御構造とも呼ばれる。その文法は次のとおりである。条件式$expr$の評価結果が{\sf true}の間、続くステートメント$stmt$を繰り返し実行する。\begin{quote}\verb|while | ($expr$) \verb| | $stmt$\end{quote}%The while loops repeatedly execute a statement block while its condition expression is true.次は、変数 \verb|a| が 0 より大きい間、繰り返し実行される。\begin{ksource}a = 1;while(a > 0) {   a = Int.random(10);           // 乱数生成   print a;}\end{ksource}\subsection{無限ループ}{\sf while}文の条件式に定数として{\sf true}を与えれば、常に真であるため無限にループを繰り返すことになる。\begin{ksource}while(ture) {   // 無限ループ}\end{ksource}注意：無限ループは、{\sf break}文を内部で用いるか、{\sf throw}文による大域ジャンプによって抜け出すことができる。そのため、多くのプログラマは何らかの脱出方法を用意して、確信犯的に無限ループを使用している。Konoha コンパイラは、本当に無限ループかどうか判定をするのは難しいため、エラーも警告も出力しない。\subsection{{\sf do/while} 文}%The do-while loops differ in that the condition is tested after the statement block has been executed. {\sf do/while}文は、条件判定の順序が異なる{\sf while}ループのバリエーションである。\begin{quote}\verb|do | $stmt$ \verb| while | ($expr$);\end{quote}{\sf do/while} ループは、先にステートメント$stmt$を一度実行したあと、条件式$expr$によって繰り返しの判定を行う。{\sf while}文と{\sf do/while}文の違いは、{\sf while}文が条件に次第では一度もステートメントを実行しないこともありえるのに対し、{\sf do/while}文の方は必ず１回はループが実行される点にある。\begin{ksource}do {   a = Int.random(10);   print a;}while(a > 0);\end{ksource}\section{{\sf for} 文}%The for loops are a conventional alternative to the while loops with special clauses for initialization and iteration of a loop variable.{\sf for} 文は、$n$回の繰り返しなどを書くときに便利な{\sf while}文の置き換えである。最初のステートメント$stmt_1$でループに入る前の状態の初期化を行い、ステートメント$stmt_3$でループを実行したのちの状態の変化、条件式$expr_2$でループの終了判定を行う。\begin{quote}\verb|for (| $stmt_1$ \verb|; | $expr_2$ \verb|; | $stmt_3$ \verb|) | $stmt$;\end{quote}{\sf for} 文は、ある回数を繰り返し実行するときに多く利用される。実際、次の{\sf for}文と{\sf while}文は全く同じであるが、多くの慣れたプログラマにとって、{\sf for}文の方が{\sf while}文よりも読みやすく処理の内容も把握しやすい。\begin{ksource}for(i = 0; i < 10; i++) {   // for 版   print i;}i = 0;                      // while 版while(i < 10) {   print i;   i++;}\end{ksource}{\sf for}文は、C/C++やJava で広く使われているため、Konoha でも採用となった。ただし、モダンなプログラミングスタイルでは、{\sf for}文よりも、イテレーションパターンを扱う {\sf foreach}文（後述）の方が好まれる。\subsection{{\sf for}文とイテレーション}モダンなオブジェクト指向プログラミングでは、繰り返しのループ処理はイテレーションパターンを用いることが多くなっている。Javaは、Java5からイテレーションを扱うため、{\sf for}文を独自に拡張している。\begin{ksource}for(Object e : list.iterator()) {   print e;}\end{ksource}Konoha では、イテレーションを扱う専用のステートメントとして、後述するとおり、{\sf foreach}文を導入している。ただし、Java 風の拡張{\sf for}文も、Konoha スタイルの{\sf foreach}文に翻訳されて実行される。\begin{ksource}foreach(Object e in list.iterator()) {   print e;}\end{ksource}\section{{\sf break}文と{\sf continue}文}%The break statement ends the statement block of a while loop, for loop, or foreach loop:Konoha は、{\sf break}文と{\sf continue}文という2種類のループ制御のステートメントをもっている。{\sf break}文を使うと、現在繰り返しているループ構造のブロックから抜け出すことができる。\begin{kshell}while(true) {   dice  = Int.random(6) + 1;   dice2 = Int.random(6) + 1;   print dice, dice2;   if(dice == dice2) break;    // ループから抜ける}\end{kshell}% The continue statement skips the remaining statements in the loop and restart the loop with the next iteration status. {\sf continue} 文を使うと、現在繰り返しているループ構造のブロックの残りのパートをスキップする。\begin{kshell}for(i = 0; i < 10; i++) {   if(i % 2 == 0) continue;    // ループの先頭へ   print i;}\end{kshell}\subsection{多重ループとラベル}ループ構造は、{\sf while}文や{\sf for/foreach}文を組み合わせて、多重ループを作ることができる。多重ループ中では、{\sf break} 文や{\sf continue}文を用いても、どのループを対象としているか曖昧になる。伝統的なC/C++, Java の定義では、最も内側のループのみ対象としてきたが、外側のループを対象としたい場合も多くある。そこで、ループにラベルをつけることで、どのループからの{\sf break}/{\sf continue}なのか明示的に示すことができる。また、ラベルを省略すれば、今まで通り暗示的に最も内側のループが対象となる。\begin{kshell}OUTER: for(y = 0; y < 8; y++) {   INNER:    for(x = 0; x < 8; x++) {      print x, y;      if (x == y) continue OUTER; /* 外側 */      if (x < y) break; /* 内側 */   }}\end{kshell}\section{{\sf foreach}文}%The foreach statement iterates over each element in an Iterator object. {\sf foreach} は、イテレータパターンを扱う専用のループ構造である。{\sf foreach}文は、次の２種類のバリエーションが存在するが、どちらもイテレータ評価式$itr$によるイテレータ内の各オブジェクトをイテレーション変数$var$に代入し、イテレータ内のオブジェクトがなくなるまで、ステートメント$stmt$の実行を繰り返す。\begin{quote}\verb|foreach(| $var$ \verb| in | $itr$ \verb|) | $stmt$; \\\verb|foreach(| $var$ \verb| from | $itr$ \verb|) | $stmt$; \\\end{quote}{\sf foreach}文は、多くの場合、{\sf for} 文を用いるよりも可読性が高くなり、また（専用命令のおかげで）高速な処理が期待される。\begin{kshell}>>> a = [0, 1, 2]>>> for(i = 0; i < |a|; i++) {   // for版(古風)...   n = a[i];...   print n;... }n=0n=1n=2>>> foreach(n from a) {          // foreach版...   print n;... }n=0n=1n=2\end{kshell}\subsection{イテレータの評価式}{\sf foreach} 文の {\sf in}/{\sf from} 節は、任意の式からイテレータをえるため、イテレータ評価式と呼ばれる。Konoha では、イテレータをえる方法は、マッピングによる方法とイテレータ演算子を用いる方法の2種類が存在し、{\sf foreach}文ではイテレーション要素の型が与えられているかどうかで、自動的に使い分けられる。\subsubsection{型が与えられている場合}イテレーション要素の型が決まっている場合、つまりイテレーション変数の型が明示的に与えられている場合、{\sf foreach}文は、マッピングによってイテレータを評価する。つまり、次の場合、イテレーション変数 {\tt line}は{\sf String}型であるため、イテレーション評価式は、\verb|(String..)(file)|で評価される。\begin{ksource}file = new InputStream("file.txt");foreach(String line from file) {   print line;}\end{ksource}\subsubsection{型が与えられている場合}イテレーション要素の型が決まっていない場合、{\sf foreach}文は、イテレーション演算子でイテレータを取り出す。次の場合、\verb|(file)..|で評価される。同時に、このとき得られたイテレーションの型(\verb|int..|)からイテレーション変数 {\sf tt} の型は、\verb|int|と型推論される。\begin{ksource}file = new InputStream("file.txt");foreach(ch from file) {   print ch;}\end{ksource}\subsection{フィルタと変換}{\sf foreach} 文の {\sf in}/{\sf from} は、ほぼ同じ動作をする。違いは、イテレータから得られるオブジェクトとイテレーション変数の型が異なった場合、 フィルタ処理にするか、変換を試みるかの違いである。\subsubsection{{\sf in}節：型検査によるフィルタ}{\sf foreach} 文と {\sf in} は、多くのプログラミング言語で組み合わせられているペアであり、イテレータ内部のものを加工せずに取り出す意味論に近いため、型検査によるフィルタ処理を行っている。\begin{kshell}>>> a = ["naruto", 9, "gahra", 1];>>> foreach(String s in a) {...   print a;... }a="naruto"a="gahra"\end{kshell}\subsubsection{{\sf from}節：マッピングによる変換}{\sf from}節は、本来、次節で述べる通り、 クエリー言語に由来しており、特別に変換の意味と結びつけられたものではないが、Konoha のforeach 文では変換しながらのイテレーション処理と定義されている。変換できなかったオブジェクトは、無視される。\begin{kshell}>>> a = ["naruto", 9, "gahra", 1];>>> foreach(String s in a) {...   print a;... }a="naruto"a="9"                          // String へ変換a="gahra"a="1"                          // String へ変換\end{kshell}\subsection{{\sf where}節*}Konoha における {\sf foreach} 文は、SQLやXMLQueryなど、クエリー言語をモデルにしている。そのため、クエリー言語の{\sf where} 節に相当する検索条件を書くことができる。\begin{quote}\verb|foreach(| $var$ \verb| from | $itr$ \verb| where | $expr$ \verb|) | $stmt$; \\\end{quote}現在は、{\sf where}節による条件検索は、Konoha 言語処理系の上で実行されているため、それほど高速ではない。将来は、{\sf foreach}文の処理を一部ダイレクトにクエリー展開し、データソースアクセスとスクリプティングをシームレスに統合する計画がある。\begin{ksource}foreach(Person p          from 'db:PERSON_TBL'          where p.age > 20 and p.age <= 60) {   print p.name, p.salary;}\end{ksource}\section{ステートメント・アノテーション*}Konoha は、全てのステートメントに対し、アノテーションを付けることで、ステートメントの意味や振る舞いを拡張することができる。アノテーションは、\verb|@|マークで始まる識別子であり、ひとつのステートメントに対し、複数のアノテーションを同時に与えることもできる。ただし、アノテーションとステートメントの間にセミコロン(;)を入れてはならない。\begin{ksource}@Date print n;@Const @Nullable String s;\end{ksource}各ステートメントによって、対応しているアノテーションの種類は異なる。未定義のアノテーションを利用しても、現在のところ、エラーも警告も発生しない。将来は、ユーザが自由に拡張したアノテーションを使うフレームワークを用意する予定である。%\section{{\sf try-catch-finally}}%Konoha は、モダンな例外処理機構を備えています。\begin{comment}\begin{kshell}try {   in = new InputStream("/dev/null");   line = in.readLine();}catch(IO!! ex) {   print ex;}catch(Security!! ex) {   print ex;}finally {   in.close();}\end{kshell}\end{comment}