\chapter{オペレータ}オペレータとは、演算子(operator)のことである。1つ以上の式を結びつけて評価する機構である。\section{代入演算子}代入演算子は、変数 x に 右辺式 y を評価した結果を代入(格納)する演算子である。\begin{quote}\begin{jverbatim}x = y                       | y の評価値をxに代入する\end{jverbatim}\end{quote}左辺値\verb|x|となりうる値は、変数、プロパティ変数、フィールド、インデックサに限られる。定数は、未定義の場合に限り、定数値を定義するために代入することができる。次は、代入可能な右辺値の例である。\begin{quote}\begin{jverbatim}name = "naruto"$name = "naruto"p.name = "naruto"   p["name"] = "naruto"\end{jverbatim}\end{quote}Konohaでは、代入自体も式として扱うことができる。つまり、代入 \verb|x = y| の評価値は、x となる。したがって、次のような複数の変数に同じ値を代入することも可能である。（本当に？）\begin{quote}\begin{jverbatim}x = y = 1                   // x には、(y = 1) の値が代入\end{jverbatim}\end{quote}\section{コール演算子}コール演算子\verb|()|は、メソッド/関数 \verb|f|、コンストラクタ\verb|C|、もしくはフォーマッタ\verb|%f|に続いて用いられ、メソッド/関数を呼び出すときに用いる。括弧\verb|()|の中には、0個以上のパラメータ/引数を\verb|,|で区切って与えることができる。コール演算子の評価値は、メソッド/関数の戻り値となる。ただし、メソッド/関数の戻り値void 型の場合は、評価値はない。\begin{quote}\begin{jverbatim}f()                         | 関数 f()のコールo.f()                       | o のメソッドf()をコールnew C()                     | クラスCのコンストラクタをコール%f(o)                       | o のフォーマッティング\end{jverbatim}\end{quote}コール演算子で与えられるパラメータは、メソッド/関数のパラメータで定められている。Nullable 型のパラメータは省略しても構わない。これに反する場合は、型エラーとなる。\begin{quote}\begin{jverbatim}>>> fibo(10)55>>> Math.abs(-1)1.000000\end{jverbatim}\end{quote}コール演算子は、第一パラメータが文字リテラルである場合のみ、括弧\verb|()|自体を省略することもできる。\begin{quote}\begin{jverbatim}>>> c.query """select name, salary from PERSON_TBL  where age > 45 and age < 65;"""\end{jverbatim}\end{quote}\section{アドレス演算子} \index{あどれすえんさんし@アドレス演算子}アドレス演算子は、変数 x の値が格納されているアドレスを返す。ただし、Konoha はポインタ演算をサポートしていないため、この機能は完全にクラスルーム目的で導入されている。\begin{quote}\begin{jverbatim}&x                          | x のアドレス\end{jverbatim}\end{quote}Konohaは、ポインタ型をサポートしていないため、アドレス演算子の演算結果は、int 型である。\verb|%p|フォーマッタを使えば、アドレスとして表示される。\begin{quote}\begin{jverbatim}>>> s = "hello, world">>> %p(&s)00000000\end{jverbatim}\end{quote}\section{比較演算子}%The comparators are defined for all objects. If two of objects are not comparable it will throw an exception. 比較演算子は、二つの値 x, y を比較するとき用いられ、結果は {\sf true} か {\sf false} である。\begin{quote}\begin{jverbatim}x == y                      | 等しいか？x != y                      | 等しくないか？x < y                       | より小さいか？x <= y                      | 以下か？x > y                       | より大きいか？x >= y                      | 以上か？\end{jverbatim}\end{quote}Konohaでは、全ての型に対して x, y の比較が可能である。これは常に意味のある比較となることを保証しない。概念的に比較が難しい場合、x, y の型が異なる場合は、数値の比較など特別なケースをのぞいて、オブジェクトID（アドレス値）の比較が返される。どちらにしても、比較演算の結果は、一意となる。\begin{quote}\begin{jverbatim}>>> 1 < 2.0true>>> 1 == "1"false\end{jverbatim}\end{quote}\subsection{マッチング演算子}マッチング演算子は、Perl に由来し、主に正規表現と文字列のマッチングに用いられる。\begin{quote}\begin{jverbatim}x =~ y                      | xは、パターンyと等しいか？\end{jverbatim}\end{quote}マッチング演算子は、\verb|==|と異なり、対称ではない。パターンは、必ず右辺に与える必要がある。\begin{quote}\begin{jverbatim}>>> s = "hello, world">>> s =~ /w.*d/true\end{jverbatim}\end{quote}\subsection{instanceof 演算子}instanceof演算子は、Java に由来し、x がクラスCのインスタンスであるか判定する。Konohaは、純オブジェクト指向言語であり、全ての値は何らかのクラスのインスタンスである。そのため、任意のxに対して、instanceof を用いることができる。\begin{quote}\begin{jverbatim}>>> 1 instaceof Floatfalse>>> 1 instanceof Numbertrue\end{jverbatim}\end{quote}また、null はどのクラスのインスタンスでないため、常に instanceof 演算子の結果は、{\sf false} となる。ただし、{\sf Any}型のみ {\sf true}となる。\begin{quote}\begin{jverbatim}>>> null instaceof Objectfalse>>> null instaceof Anytrue\end{jverbatim}\end{quote}\section{論理演算子}論理演算子は、C/C++, Java互換の記法とPython 互換の記法の両方をサポートしている。どちらを使っても構わないが、C/C++, Java との互換性を重んじるなら、\verb|&&|, \verb#||#, \verb|!|を用いる方が無難である。\begin{quote}\begin{jverbatim}x and y                     | x かつ y がtrueのときx && y                      |x or y                      | x または y がtrueのときx || y                      |not y                       | x がfalse のとき!(y)                        |  \end{jverbatim}\end{quote}\begin{quote}\begin{jverbatim}>>> a = 1>>> b = 2>>> a == 1 && b == 2true>>> a == b || a < btrue>>> !(a == b)true\end{jverbatim}\end{quote}論理演算を混在したとき、\verb|!|, \verb|&&|, \verb#||# の順に演算される。ただし、演算順位で誤解を生じさせないように、\verb|()|で優先的に演算する式を囲んだ方がよい。\begin{quote}\begin{jverbatim}!(a == 1) && b == 2 || a > b         // ((!(a == 1)) && b == 2) || (a > b) と同じ!(a == 1) || b == 2 and a > b         // (!(a == 1)) || ((b == 2) && (a > b)) と同じ\end{jverbatim}\end{quote}\subsection{条件演算子}条件演算子は、条件によって演算が切り替わる演算子である。Konoha は、次の2種類の演算子をサポートしている。\begin{quote}\begin{jverbatim}x ? y : z                   | xがtrueのときy、そうでなければzx ?? y                      | xがnullのときy\end{jverbatim}\end{quote}演算子 \verb|x ? y : z| は、3項演算子とも呼ばれ、条件式\verb|x|の結果によって、式\verb|y| か 式\verb|z|が評価される。3項演算子は、読みにくくなるので、各式の周りは\verb|()|で囲んだ方がよい。\begin{quote}\begin{jverbatim}>>> a = 1; b = -1;>>> a = (a < b) ? (a) : (b);>>> a-1\end{jverbatim}\end{quote}演算子 \verb|x ?? y| は、C\#で導入された null 検査用の条件演算子である。意味は、\verb|(x != null) ? x : y| と同じである。ただし、null 検査を連続するときは、こちらの方がはるかに読みやすい。\begin{quote}\begin{jverbatim}>>> name = student["name"] ?? ninja["name"] ?? "unknown";\end{jverbatim}\end{quote}\section{算術演算子}% The arithmetic operators (+ - * / %) are defined for all numeric types, such as Int and Float.算術演算子は、2つの数値 x, y に対し、四則演算を行うときに用いられる。また、文字列など一部のクラスには算術演算子を連結や分離などの意味で定義されていることもある。\begin{quote}\begin{jverbatim}x + y                       | 加算x - y                       | 減算x * y                       | 乗算x / y                       | 除算x % y                       | 余り（モジュロ）x mod y                     | \end{jverbatim}\end{quote}モジュロ演算子 \verb|%| は、C/C++, Javaで広く採用されているが、フォーマッタ名と区別しにくいので、{\sf mod} を使うことが推奨されている。\begin{quote}\begin{jverbatim}>>> 1 + 2 * 37\end{jverbatim}\end{quote}\subsection{算術代入}算術代入は、代入演算子と算術演算子を組み合わせたシンタックスシュガーである。\begin{quote}\begin{jverbatim}x += y                      | x = x + yx -= y                      | x = x - yx *= y                      | x = x * yx /= y                      | x = x / y\end{jverbatim}\end{quote}\subsection{インクリメントとデクリメント}Konoha は、"Everything is an Object" の世界で、Int オブジェクトは Immutable なので、本来の意味でインクリメントとデクリメントをサポートできない。しかし、あまりに利用者からの要望が多いため、シンタックスシュガーで対応している。現在のところ、前置、後置演算の区別はない。\begin{quote}\begin{jverbatim}x++                         | x = x.opNext()++x                         | x = x.opNext()x--                         | x = x.opPrev()--x                         | x = x.opPrev()\end{jverbatim}\end{quote}Konohaでは、インクリメント/デクリメント演算子は、次のようにステートメントとして利用する場合、安心して用いることができる。\begin{quote}\begin{jverbatim}for(i = 0; i < 10; i++) print i;\end{jverbatim}\end{quote}\section{ビット演算子}Konohaは、Cスタイルのビット演算子をInt型に対してサポートしている。スクリプティング言語において、これらの演算子を多用することは稀であり、これらは教育用を主目的\footnote{バーチャルマシンにおいて専用命令としてチューニングされないと意味である。}として用意されている。\begin{quote}\begin{jverbatim}~x                          | ビット反転x & y                       | 論理積x | y                       | 論理和x ^ y                       | 排他論理和(XOR)x << y                      | 左シフトx >> y                      | 右シフト\end{jverbatim}\end{quote}フォーマッタ\verb|%bits| は、ビット演算子の結果を表示するとき利用できる。\begin{quote}\begin{jverbatim}>>> %bits(~0)11111111 11111111 11111111 11111111>>> %bits(1 << 2)00000000 00000000 00000000 00000010\end{jverbatim}\end{quote}\section{シーケンス演算子}%Konoha supports several convenient operators for sequence/set objects, such as Array, byte[], HashMap, HashSet, DictMap, and DictSet. Konoha は、シーケンス（順序を保って並んだ集合）に対して、その操作に関する一連の演算子を提供し、それらを総称してシーケンス演算子と呼ぶ。代表的なシーケンスの例は、{\sf Array}, {\sf byte[]}, {\sf String}などがある。\begin{quote}\begin{jverbatim}|s|                         | シーケンス s のサイズs[n]                        | n番目の値 s[n] = x                    | n番目に値xをセットするs[] = x                     | 全部に値xをセットするx in? s                     | s に xが含まれているか？s << x                      | s への x の追加\end{jverbatim}\end{quote}シーケンス演算子では、シーケンスの要素の種類によらず、シーケンスのインデックス\verb|n|に対して、常に $0 \le n < \verb#|s|#$が保証される。(ただし、{\sf DictMap}や{\sf HashMap}のように、インデックスの代わりにキーを用いる場合はこの限りでない。)\begin{quote}\begin{jverbatim}>>> a = [0, 1, 2, 3]>>> |a|4>>> a[1]1>>> a[-1]OutOfIndex!!: \end{jverbatim}\end{quote}インデックス\verb|n|が最大値\verb#|s|#を超えた場合は、\verb|OutOfIndex!!|例外となる。インデックスの値がマイナス\footnote{配列のBoundary Check 最適化を考えて、Python 風の最後尾から数えてインデックスし直す拡張は便利であるが採用は見送られた。}のときも同様である。演算子 \verb|<<|は、特別なシーケンス演算子であり、複数の要素を連続して追加することもできる。\begin{quote}\begin{jverbatim}>>> a = [1]>>> a << 2 << 3 << 5 << 7;>>> a[1, 2, 3, 5, 7]\end{jverbatim}\end{quote}スライシングは、シーケンスから部分シーケンスを取り出す演算子である。Python のスライシング演算子とよく似ているが、Konoha では部分シーケンスの定義の仕方が3種類用意されている。\begin{quote}\begin{jverbatim}s[x..y]                     | x番目からy番目(含む)までs[x..<y]                    | x番目からy番目まで                            |  s[x..(y-1)] と同じ s[x..+y]                    | x番目からy個の部分                            |  s[x..(x+y)] と同じ \end{jverbatim}\end{quote}文字列は、シーケンスの一種であり、スライシングで部分文字列を得ることができる。\begin{quote}\begin{jverbatim}>>> s = "konoha">>> s[2..3]"no">>> s[2..<3]"n">>> s[2..+3]"noh"\end{jverbatim}\end{quote}よく似た演算子が3種類存在する理由は、これらはよく混同されて間違えるためである。逆に、３種類、範囲除外(\verb|..<|)やオフセット(\verb|..+|)をイメージしやすい演算子を導入することで、どれかを正しく使いやすくなる。また、スライシング\verb|s[x..y]|の範囲 \verb|x y|は、それぞれ省略可能である。省略したときは、それぞれ \verb|x = 0|, \verb#y = |s| - 1#が初期値として採用される。\begin{quote}\begin{jverbatim}>>> s = "konoha">>> s[2..]"noha">>> s[..4]"nono">>> s[..]                  // シーケンスのコピー"konoha"\end{jverbatim}\end{quote}\section{キャスト演算子}Konoha は、オブジェクト間のデータ変換や意味変換を強力にサポートするマッピング機能を独自に導入している。これらは、C/C++, Java 言語でおなじみのキャスト演算子に統合され、利用可能である。%The casting operator is an integral part of Konoha.\begin{quote}\begin{jverbatim}(T)x                        | xの型Tへの変換（キャスト）x to? T                     | xは型Tへ変換可能か？\end{jverbatim}\end{quote}マップキャスト演算子\verb|(T)x|は、ソース型\verb|typeof(x)|とターゲット型\verb|T|の関係で動作が異なる。サブタイプの関係が成り立つ場合は、通常どおり、アップキャスト、もしくはダウンキャストされる。それ以外の場合は、マッパーが検索され、それが評価される。\begin{quote}\begin{jverbatim}>>> Object o = "123";>>> s = (String)o;                  // ダウンキャスト>>> n = (int)o;                     // マップキャスト>>> n123\end{jverbatim}\end{quote}これらの演算子は、マッピング機能を応用して実現されている。詳しくは、「第\ref{chapter:mapping}章 マッピング機能とデータ変換」で述べる。\section{セマンティック演算子**}Konoha は、オブジェクト指向モデルの軽量オントロジ拡張を行い、クラスやオブジェクト間の意味的な関係を比較することができる。\begin{quote}\begin{jverbatim}x isa? y                    | x は、y か？ IS-A 関係 x === y                     | x と y は意味的に等しいか？\end{jverbatim}\end{quote}Konohaは、文字列や数値に意味タグを付加することができる。次は、華氏(32.0F)と摂氏(0.0C)の比較である。\begin{quote}\begin{jverbatim}>>> Float:F temp = 32.0F;>>> temp == 0.0C;false>>> temp === 0.0C;true\end{jverbatim}\end{quote}これらの演算子は、マッピング機能を応用して実現されている。詳しくは、「第\ref{chapter:semanticprogramming}章 セマンティックプログラミング」で述べる。\chapter{ステートメント}%A Konoha program is simply a collection of statements. This section describes the various statements in Konoha and explains their syntax. If you are familiar with C, C++, and Java, you will notice that the statements in Konoha are very similar, and you'll be able to skim this section quickly. プログラムは、ステートメントの集まりである。本章では、Konoha の基本的なステートメントとその文法を説明する。しかし、あらかじめ断っておくが、本章で紹介するKonohaステートメントは、C/C++やJavaとほぼ完全な互換性がある。書く方は頑張ったわりには、読者から読み飛ばされてしまう章である。なお、ステートメントの一般的な訳語は、「文」である。本来、ステートメントに統一すべきかも知れないが、if ステートメントと呼ぶのは冗長な気がするので、広く慣習的に用いられているい[if文]を用いている。\section{式}%The simplest kinds of statements in Konoha are expressions that change a program status. Assignment statements are one major category of expression statements. For example:もっとも簡単なステートメントは、プログラムの状態を変更する式(expression)である。代入式は、もっともよく使われるステートメントである。\begin{quote}\begin{jverbatim}s = "Hello " + name;i *= 3;\end{jverbatim}\end{quote}%The increment and decrement operators, ++ and --, are related to assignment statements. インクリメント演算式(++)、デクリメント演算式(--)は、代入式の一種である。Konoha は、前置/後置の違いはなく、次の式は \verb|counter = counter + 1|と同じである。\begin{quote}\begin{jverbatim}counter++;\end{jverbatim}\end{quote}%Function/method calls are another major category of expression statements. For example:関数/メソッドコールは、もうひとつの代表的な式によるステートメントである。\begin{quote}\begin{jverbatim}fibo(16);Math.sin(0.5);\end{jverbatim}\end{quote}%Before proceeding next, recall that statements in Konoha are separated from each other with semicolons. It is a good idea to get in the habit of using semicolons everywhere.\section{ブロック}\index{block@block}% Konoha has a way to combine a number of statements into a single statement, or statement block. This is done simply by enclosing any number of statements with curly braces. ステートメントブロックは、0個以上のステートメントまとめてひとつのステートメントとして扱えるようにする。これは、任意のステートメントを中括弧 \verb|{ }|で囲むことで作ることができる。\begin{quote}\begin{jverbatim}{	x = Math.PI;	a = Math.cos(x);	print a;}\end{jverbatim}\end{quote}ブロックを使うときは、インデントすると読みやすい。%Note that although this statement block acts as a single statement, it does not necessary end with a semicolon. The elemental statements within the block end in semicolons, but the block itself does not.\section{変数の型宣言}\index{かたせんげん@型宣言}Konoha の変数は、静的に型付けされており、新しい変数を使うとき、型宣言が必要となる。C/C++やJavaと同様、型名 変数名の形式で、必要に応じて変数の初期値を与えられる。また同じ型であれば、複数の変数をひとつのステートメントで宣言できる。\begin{quote}\begin{jverbatim}String s;                          // 初期値なしString t = "hello,world";          // 初期値ありString u, v = "ABC";               // 同じ型の複数の変数宣言\end{jverbatim}\end{quote}Java との大きな違いは、初期値の扱いである。Konoha は、@Nullable 修飾子（もしくは型名のあとに\verb|?|)追加しなかれば、全て NonNull 型となる。したがって、初期値の指定がない場合の初期値は、null ではなく、そのクラスのデフォルト値となる。\begin{quote}\begin{jverbatim}>>> String s>>> s""\end{jverbatim}\end{quote}逆に、C\#風に\verb|?|を型名に付けるか、@Nullableアノテーションを用いれば、null を保持可能な変数となる。この場合の初期値は、null である。\begin{quote}\begin{jverbatim}>>> String? s2                     // Nullable>>> s2null\end{jverbatim}\end{quote}\section{if 文}\index{if@if文}%6.3	if%The if statement is the fundamental control statement that allows Konoha to execute statements conditionally. This statement has two forms. The first is:if 文は、もっとも基本的な制御ステートメントであり、条件に応じて実行するステートメントの切り替えることを可能にする。if 文には、2種類の形式がある。次は、簡単な形式である。\begin{quote}\verb|if| ($expr$) $stmt$\end{quote}%In this form, the expression is first evaluated. If the resulting value is true, then statement is executed. If expression is false, statement is not executed. For example:この形式では、条件式$expr$がまず評価される。その結果が、{\sf true}であれば、それに続くステートメント$stmt$が実行される。もし条件式の結果が{\sf false}であれば、ステートメント$stmt$は実行されない。\begin{quote}\begin{jverbatim}if (n mod 2 == 0) print "even";\end{jverbatim}\end{quote}%As mentioned in the previous section, you can always replace a single statement with a statement block.  if 文に続くステートメントとして、ブロックを用いることもできる。\begin{quote}\begin{jverbatim}if (n mod 2 == 0) {	print "even";}\end{jverbatim}\end{quote}%The indention used in these examples is not mandatory. Using line breaks and indention as shown here makes the code easier to read and understand. %The second form of the if statement introduces an else clause that is executed when expression is false. Its syntax is:第二の形式は、{\sf else}節を導入したものである。\index{else@else節}\begin{quote}\verb|if| ($expr$) $stmt1$ \verb|else| $stmt2$\end{quote}%In this form of the statement, expression is evaluated, and if it is true, statement1 is executed; otherwise, statement2 is executed. For example:この形式のifでは、まず条件式$expr$が評価され、もしそれが{\sf true}であればステートメント$stmt1$が実行され、そうでなければ$stmt2$が実行される。\begin{quote}\begin{jverbatim}if (n mod 2 == 0) {	print "even";} else {	print "odd";}\end{jverbatim}\end{quote}%\subsection{if ... else if ... }\section{switch 文}\index{switch@switch文}%6.4	switchThe switch statement is not supported in the version 0.5 of Konoha.\section{while/do-while 文}\index{while@while文}% The while loops repeatedly execute a statement block while its condition expression is true.%6.5	while%The while statement is the basic statement that allows Konoha to perform repetitive actions. It has the following syntax:{\sf while}文は、Konohaにおいてステートメントを繰り返し実行させる基本的なステートメントである。その文法は次のとおりである。\begin{quote}\verb|while| ($expr$) $stmt$\end{quote}%The while loops repeatedly execute a statement block while its condition expression is true.{\sf while} ループは、条件式$expr$が{\sf true}の間、続くステートメント$stmt$を繰り返す。次は、変数 a が0より大きい間、繰り返し実行される。\begin{quote}\begin{jverbatim}a = 1;while(a > 0) {	a = Int.random(10);	print a;}\end{jverbatim}\end{quote}%The do-while loops differ in that the condition is tested after the statement block has been executed. Konohaでは、ループを実現するステートメントとして、{\sf do-while}文のバリエーションがある。\begin{quote}\verb|do| $stmt$ \verb|while| ($expr$);\end{quote}{\sf do-while} ループは、先にステートメント$stmt$を一度実行したあと、条件$expr$によって繰り返しの有無を定を行う。{\sf while}と{\sf do-while}の違いは、{\sf while}が条件に次第では1回もステートメントが実行されないのに対し、{\sf do-while}の方は必ず１回は実行される点である。\begin{quote}\begin{jverbatim}do {	a = Int.random(10);	print a;}while(a > 0);\end{jverbatim}\end{quote}\section{{\sf for} 文}%The for loops are a conventional alternative to the while loops with special clauses for initialization and iteration of a loop variable.{\sf for} 文は、変数の初期化とその値の増減を繰り返すときに便利なwhile 文の置き換えである。実際、次のソースコードは、\begin{quote}\begin{jverbatim}for(i = 0; i < 10; i++) {	print i;}\end{jverbatim}\end{quote}以下の{\sf while}文と全く同じである。\begin{quote}\begin{jverbatim}i = 0;while(i < 10) {	print i;	i++;}\end{jverbatim}\end{quote}\section{{\sf break} 文 と {\sf continue} 文}%The break statement ends the statement block of a while loop, for loop, or foreach loop:Konoha は、{\sf break}と{\sf continue}という2種類のループ制御のステートメントをもっている。{\sf break} 文を使うと、現在繰り返しているループ構造のブロックから抜け出すことができる。\begin{quote}\begin{jverbatim}while(true) {	dice  = Int.random(6) + 1;	dice2 = Int.random(6) + 1;	print dice, dice2;	if(dice == dice2) break;    // ゾロ目の場合、終了}\end{jverbatim}\end{quote}% The continue statement skips the remaining statements in the loop and restart the loop with the next iteration status. {\sf continue} 文を使うと、現在繰り返しているループ構造のブロックの残りのパートをスキップする。\begin{quote}\begin{jverbatim}for(i = 0; i < 10; i++) {	if(i % 2 == 0) continue;	print i, ...;}\end{jverbatim}\end{quote}\subsubsection{多重ループからの{\sf break}と{\sf continue}}ループ構造は、{\sf while}文や{\sf for/foreach}文を組み合わせて、多重ループを作ることができる。多重ループの中では、どのループを対象として、{\sf break}したり、{\sf continue} するのか問題となります。Konoha では、ループにラベルをつけることで、どのループからの{\sf break}/{\sf continue}なのか明示的に示すことができる。また、ラベルを省略すれば、今まで通り暗示的に最も内側のループが対象となる。\begin{quote}\begin{jverbatim}OUTER: for(y = 0; y < 8; y++) {	INNER: 	for(x = 0; x < 8; x++) {		if (x == y) continue OUTER; /* 外側 */		if (x < y) break; /* 内側 */		print x, y;	}}\end{jverbatim}\end{quote}\section{{\sf for/in} 文}%The foreach statement iterates over each element in an Iterator object. {\sf foreach} は、イテレータ内の各オブジェクトに対して繰り返し処理を行う専用のループ構造である。多くの場合、{\sf for} 文よりもわかりやすく、高速な処理が可能になります。\begin{quote}\begin{jverbatim}foreach(String line from new InputStream("file.txt")) {	print line;}\end{jverbatim}\end{quote}All of objects in Konoha are convertible to an Iterator object. See the upcoming "Foreach and Iteration " section for detailed information. Konoha は、{\sf foreach} 文を大きく拡張してあります。詳しくは、「第\ref{section:foreach}節 {\sf foreach}とクエリー処理」を参照してください。% All of objects in Konoha are convertible to an Iterator object. See the upcoming "Foreach and Iteration " section for detailed information. %\section{{\sf try-catch-finally}}%Konoha は、モダンな例外処理機構を備えています。\begin{comment}\begin{jverbatim}try {	in = new InputStream("/dev/null");	line = in.readLine();}catch(IO!! ex) {	print ex;}catch(Security!! ex) {	print ex;}finally {	in.close();}\end{jverbatim}\end{comment}