\chapter{オペレータ}オペレータとは、1つ以上の式を結びつけて評価する機構である。\verb|+|や\verb|=|などの演算子と呼び直した方がわかりやすいだろう。近代的なオブジェクト指向プログラミング言語は、ほとんどのオペレータはメソッドの一部として実現し、それをシンタックスシュガー（糖衣構文）として使いやすく提供している。本章では、Konoha が提供するオペレータの全体像を知るため、一般的な紹介を行う。オペレータは、ある特定のクラスや機能と密接に関係したものも多いが、それらは後に続く章において個々に詳説される。\section{代入演算子}代入演算子は、変数 x に 右辺式 y を評価した結果を代入(格納)する演算子である。\begin{ksource}x = y                       // y の評価値をxに代入する\end{ksource}左辺値\verb|x|となりうる値は、変数、プロパティ変数、フィールド、配列や辞書に限られる。定数は、未定義の場合に限り、定数値を定義するために代入することができる。次は、代入可能な右辺値の例である。\begin{ksource}name = "naruto"$name = "naruto"p.name = "naruto"p[0] = "naruto"   p["name"] = "naruto"P = "naruto"                // 定数は、1回のみ代入可能\end{ksource}\subsection{代入式の代入*}Konohaでは、代入演算自体も式として扱うことができる。つまり、代入 \verb|x = y| の評価値は、(代入後の) x となる。したがって、次のように、同じ値を複数の変数へ代入することも可能となる。\begin{kshell}>>> y = 2>>> x = y = 1               // x には、(y = 1) の値が代入>>> x1>>> y1\end{kshell}\subsection{多値セレクタ**}データ構造から部分的な値を切り出すことは多い。これらのプログラムを簡単に書くため、多値代入を値のセレクタとして利用する拡張計画がある。\begin{kshell}>>> s = ["naruto", "sakura"]>>> a, b = s;>>> a                      // s[0] と同じ (s.opFirst())"naruto">>> b                      // s[1] と同じ (s.opSecond())"sakura"\end{kshell}\section{コール演算子}コール演算子\verb|()|は、メソッド/関数 \verb|f|、コンストラクタ\verb|new C|、もしくはフォーマッタ\verb|%f|に続いて用いられ、メソッド/関数を呼び出すときに用いる。括弧\verb|()|の中には、0個以上のパラメータ/引数を\verb|,|で区切って与えることができる。コール演算子の評価値は、メソッド/関数の戻り値となる。(ただし、メソッド/関数の戻り値void 型の場合は、評価値はない。)\begin{ksource}f()                        // 関数 f()のコールo.f()                      // o のメソッドf()をコールnew C()                    // クラスCのコンストラクタ%f(o)                      // o のフォーマッティング\end{ksource}コール演算子で与えられるパラメータは、メソッド/関数ごとに個別に定義されている。定義と異なるパラメータでコールしようとしたときは、型エラーとなる。\begin{kshell}>>> fibo(10)55>>> Math.abs(-1)1.000000\end{kshell}\subsection{コール演算子の省略}コール演算子は、パラメータの数が１個であり、かつそれが文字リテラルである場合のみ、括弧\verb|()|自体を省略することもできる。次は、\verb|c.query("""...""")|と同じであるが、省略した方がすっきりとする。\begin{kshell}>>> c.query """select name, salary from PERSON_TBL  where age > 45 and age < 65;"""\end{kshell}\section{アドレス演算子}アドレス演算子は、変数 x の値が格納されているアドレスを返す。ただし、Konoha はポインタ演算をサポートしていないため、この機能は完全にクラスルーム目的で導入されている。\begin{ksource}&x                        // x のアドレス\end{ksource}Konohaは、ポインタ型をサポートしていないため、アドレス演算子の演算結果は、int 型である。\verb|%p|フォーマッタを使えば、アドレスとして表示される。\begin{kshell}>>> s = "hello, world">>> %p(&s)00000000\end{kshell}\section{比較演算子}%The comparators are defined for all objects. If two of objects are not comparable it will throw an exception. 比較演算子は、二つの値 x, y を比較するとき用いられ、評価結果は、論理値の{\sf true} か {\sf false} である。\begin{ksource}x == y                    // 等しいか？x != y                    // 等しくないか？x < y                     // より小さいか？x <= y                    // 以下か？x > y                     // より大きいか？x >= y                    // 以上か？\end{ksource}Konohaでは、全ての型において、x, y の比較が可能である。これは常に意味のある比較となることを保証しない。特に、x と y の型が異なる場合、かつ概念的にも比較が意味をなさない場合は、オブジェクトID（アドレス値）の比較が返される。どちらにしても、比較演算の評価値は、一意となる。\begin{kshell}>>> 1 < 2.0               // 整数と浮動小数点は比較可能true>>> 1 == "1"              // 比較不可能な型false\end{kshell}\subsection{マッチング演算子}マッチング演算子は、Perl に由来し、主に正規表現と文字列のマッチングに用いられる。\begin{ksource}x =~ y                    // xは、パターンyと等しいか？\end{ksource}マッチング演算子は、\verb|==|と異なり、対称ではない。パターンは、必ず右辺に与える必要がある。\begin{kshell}>>> s = "hello, world">>> s =~ /w.*d/true\end{kshell}\subsection{{\tt instanceof} 演算子*}{\tt instanceof} 演算子は、Java に由来し、x がクラスCのインスタンスであるか判定する。Konohaは、純オブジェクト指向言語であり、全ての値は何らかのクラスのインスタンスである。そのため、任意のxに対して、{\tt instanceof} を用いることができる。\begin{ksource}x instaceof T            // x は、Tのインスタンスか？\end{ksource}整数 {\tt 1} は、{\sf Float}のインスタンスではないが、{\sf Number}のインスタンスである。{\tt instanceof} 演算子は、次のようにテストできる。\begin{kshell}>>> 1 instanceof Floatfalse>>> 1 instanceof Numbertrue\end{kshell}また、null はどのクラスのインスタンスでないため、常に {\tt instanceof} 演算子の結果は、{\sf false} となる。ただし、{\sf Any}型のみ {\sf true}となる。\begin{kshell}>>> null instanceof Objectfalse>>> null instanceof Anytrue\end{kshell}\section{論理演算子}論理演算子は、論理式（評価結果が論理値となる式）を論理的に連結し、より複雑な論理式を作る演算子である。\begin{ksource}x && y                    // x かつ y がtrueのときx || y                    // x または y がtrueのとき!(y)                      // x がfalse のとき x and y                   // x && y と同じx or y                    // x || y と同じnot y                     // !(x) と同じ\end{ksource}Konoha の論理演算子は、C/C++, Java互換の記法と、Python 由来の記法の両方をサポートしている。どちらを使っても構わないが、C/C++, Java との互換性を重んじるなら、\verb|&&|, \verb#||#, \verb|!|を用いる方が無難である。\begin{kshell}>>> a = 1>>> b = 2>>> a == 1 && b == 2true>>> a == b || a < btrue>>> !(a == b)true\end{kshell}論理演算を混在したとき、\verb|!|, \verb|&&|, \verb#||# の順に演算される。ただし、\verb|()|で囲まれた式は優先的に評価される。論理式を混在させるときは、読みやすさのため、\verb|()|で明示的に優先する論理式を与えるのがよい。\begin{kshell}>>> a = 1>>> b = 3>>> !(a == 1) && b == 3 || a < btrue>>> !(a == 1) || b == 3 && a < bfalse>>> (!(a == 1) || b == 3) && a < btrue\end{kshell}\subsection{条件演算子}条件演算子は、条件によって評価する式を切り替える演算子である。Konoha は、次の2種類の条件演算子をサポートしている。\begin{ksource}x ? y : z                 // xがtrueのときy、そうでなければzx ?? y                    // xがnullのときy\end{ksource}演算子 \verb|x ? y : z| は、3項演算子とも呼ばれ、条件式\verb|x|の評価結果によって、式\verb|y| か 式\verb|z|が評価される。3項演算子は、読みにくくなるので、各式の周りは\verb|()|で囲んだ方がよい。\begin{kshell}>>> a = 1; b = -1;>>> a = (a < b) ? (a) : (b);>>> a-1\end{kshell}演算子 \verb|x ?? y| は、C\#で導入された null 検査用の条件演算子である。意味は、\verb|(x != null) ? x : y| と同じである。ただし、null 検査を連続するときは、こちらの方がはるかに読みやすい。\begin{kshell}>>> name = student["name"] ?? ninja["name"] ?? "unknown";\end{kshell}\section{算術演算子}% The arithmetic operators (+ - * / %) are defined for all numeric types, such as Int and Float.算術演算子は、2つの数値 x, y に対し、四則演算を行うときに用いられる。また、文字列など一部のクラスには算術演算子は、連結や分離などの意味で定義されていることもある。\begin{ksource}x + y                     // 加算x - y                     // 減算x * y                     // 乗算x / y                     // 除算x % y                     // 余り（モジュロ）x mod y                   // x % y と同じ\end{ksource}モジュロ演算子 \verb|%| は、C/C++, Javaで広く採用されているが、Konoha ではフォーマッタ名と区別しにくいので、{\tt mod} を使うか、演算子の前後に明示的に空白を入れることが推奨されている。算術演算子は、四則演算の優先順位にしたがって評価される。つまり、乗算(\verb|*|)と除算(\verb|/|)の優先度は、乗算(\verb|+|)と除算(\verb|-|)より高く、同じ優先度の場合は左から順番に評価される。評価順序を変更する場合は、先に評価したい式を括弧\verb|()|で囲めばよい。\begin{kshell}>>> 1 + 2 * 37>>> 1 + 2 - 3 * 4 / 2-3>>> (1 + 2) * 39\end{kshell}\subsection{算術代入}算術代入は、代入演算子と算術演算子を組み合わせたシンタックスシュガーである。\begin{ksource}x += y                    // x = x + yx -= y                    // x = x - yx *= y                    // x = x * yx /= y                    // x = x / y\end{ksource}算術代入は、代入可能な右辺値であれば、全て適用することができる。\begin{kshell}>>> a = [0, 1]>>> a[0] += 1              // a[0] = a[0] + 1 と同じ>>> a[1, 1]\end{kshell}ただし、\verb|a[n++] += 1|のような副作用が生じる場合は、期待通りの算術代入にはならない。\subsection{インクリメントとデクリメント}Konoha は、"Everything is an Object" の世界で、Int オブジェクトは Immutable なので、本来の意味でインクリメントとデクリメントをサポートできない。しかし、あまりに利用者からの要望が多いため、シンタックスシュガーで対応している。現在のところ、前置、後置演算の区別はない。\begin{ksource}x++                       // x = x.opNext()++x                       // x = x.opNext()x--                       // x = x.opPrev()--x                       // x = x.opPrev()\end{ksource}Konohaでは、インクリメント/デクリメント演算子は、ステートメントとして利用することを推奨している。式として利用した場合、その評価順序は、将来にわたって保証されない。\begin{kshell}>>> for(i = 0; i < 3; i++) print i;i=0i=1i=2\end{kshell}\section{ビット演算子}Konohaは、Cスタイルのビット演算子をInt型に対してサポートしている。スクリプティング言語において、これらの演算子を多用することは稀であり、これらは教育用を主目的\footnote{バーチャルマシンにおいて専用命令としてチューニングされないと意味である。}として用意されている。\begin{ksource}~x                        // ビット反転x & y                     // 論理積x | y                     // 論理和x ^ y                     // 排他論理和(XOR)x << y                    // 左シフトx >> y                    // 右シフト\end{ksource}フォーマッタ\verb|%bits| は、ビット演算子の結果を表示するとき利用できる。\begin{kshell}>>> %bits(~0)11111111 11111111 11111111 11111111>>> %bits(1 << 2)00000000 00000000 00000000 00000100\end{kshell}\section{シーケンス演算子}%Konoha supports several convenient operators for sequence/set objects, such as Array, byte[], HashMap, HashSet, DictMap, and DictSet. Konoha は、シーケンス（順序を保って並んだ集合）に対して、その操作に関する一連の演算子を提供し、それらを総称してシーケンス演算子と呼ぶ。代表的なシーケンスの例は、{\sf Array}, {\tt byte[]}, {\sf String}などがある。\begin{kshell}|s|                       // シーケンス s のサイズs[n]                      // n番目の値 s[n] = x                  // n番目に値xをセットするs[] = x                   // 全部に値xをセットするx in? s                   // s に xが含まれているか？s << x                    // s への x の追加\end{kshell}シーケンス演算子では、シーケンスの要素の種類によらず、シーケンスのインデックス\verb|n|に対して、常に $0 \le n < \verb#|s|#$が保証される。(ただし、{\sf DictMap}や{\sf HashMap}のように、インデックスの代わりにキーを用いる場合はこの限りでない。)\begin{kshell}>>> a = [0, 1, 2, 3]>>> |a|4>>> a[1]1\end{kshell}\subsection{インデックスの範囲}インデックス\verb|n|が最大値\verb#|s|#を超えた場合は、\verb|OutOfIndex!!|例外となる。古いKonoha では、Python と同様に、最後尾から数えてインデックスし直していたが、配列の境界チェックの最適化を考慮に入れて、負のインデックスは見送られた。\begin{kshell}>>> a[-1] ** OutOfIndex!!: \end{kshell}\subsection{シーケンスへの追加}演算子 \verb|<<|は、特別なシーケンス演算子であり、複数の要素を連続して追加することもできる。\begin{kshell}>>> a = [1]>>> a << 2 << 3 << 5 << 7;>>> a[1, 2, 3, 5, 7]\end{kshell}\section{スライシング演算子}スライシング演算子は、シーケンスから部分シーケンスを取り出す演算子である。Python のスライシング演算子とよく似ているが、Konoha では部分シーケンスの定義の仕方が3種類用意されている。\begin{ksource}s[x..y]                   // x番目からy番目(含む)までs[x..<y]                  // x番目からy番目まで                          //  s[x..(y-1)] と同じ s[x..+y]                  // x番目からy個の部分                          //  s[x..(x+y)] と同じ \end{ksource}文字列は、シーケンスの一種であり、スライシングで部分文字列を得ることができる。\begin{kshell}>>> s = "konoha">>> s[2..3]"no">>> s[2..<3]"n">>> s[2..+3]"noh"\end{kshell}よく似た演算子が3種類存在する理由は、これらはよく混同されて間違えるためである。逆に、３種類、範囲除外(\verb|..<|)やオフセット(\verb|..+|)をイメージしやすい演算子を導入することで、どれかを正しく使いやすくなる。また、スライシング\verb|s[x..y]|の範囲 \verb|x y|は、それぞれ省略可能である。省略したときは、それぞれ \verb|x = 0|, \verb#y = |s| - 1#が初期値として採用される。\begin{kshell}>>> s = "konoha">>> s[2..]"noha">>> s[..4]"kono">>> s[..]                  // シーケンスのコピー"konoha"\end{kshell}\section{キャスト演算子}Konoha は、オブジェクト間のデータ変換や意味変換を強力にサポートするマッピング機能を独自に導入している。これらは、C/C++, Java 言語でおなじみのキャスト演算子に統合され、利用可能である。\begin{ksource}(T)x                      // xの型Tへの変換（キャスト）x to? T                   // xは型Tへ変換可能か？\end{ksource}マップキャスト演算子\verb|(T)x|は、ソース型\verb|typeof(x)|とターゲット型\verb|T|の関係で動作が異なる。サブタイプの関係が成り立つ場合は、通常どおり、アップキャスト、もしくはダウンキャストされる。それ以外の場合は、マッパーが検索され、それが評価される。\begin{kshell}>>> Object o = "123";>>> s = (String)o;                  // ダウンキャスト>>> n = (int)o;                     // マップキャスト>>> n123\end{kshell}また、マッピングが定義されていない場合、つまりキャストができない場合は、\verb|ClassCast!!|例外となる。\begin{kshell}>>> (int)true ** ClassCast!!: Boolean ==> Int\end{kshell}これらの演算子は、マッピング機能を応用して実現されている。詳しくは、「第\ref{mapping}章 マッピング機能とデータ変換」で述べる。\section{イテレータ演算子*}イテレータ演算子は、オブジェクトから(標準)イテレータを得るときに用いる。{\sf foreach} 文において、イテレータを生成するときに用いる（内部）演算子であるが、プログラマが用いても構わない。\begin{ksource}x..                       // x の(標準)イテレータ\end{ksource}次の例では、整数配列\verb|Int[]|からイテレータ(\verb|Int..|)を得ている。\begin{kshell}>>> a = [0, 1, 2]>>> typeof(a..)>>> a..123\end{kshell}イテレータ型や標準イテレータの定義は、「第\ref{iteration}章 イテレーション」で詳しく述べる。\section{セマンティック演算子**}Konoha は、オブジェクト指向モデルの軽量オントロジ拡張を行い、クラスやオブジェクト間の意味的な関係を比較することができる。\begin{ksource}x isa? y                  // x は、y か？ IS-A 関係 x === y                   // x と y は意味的に等しいか？\end{ksource}Konohaは、文字列や数値に意味タグを付加することができる。次は、華氏(32.0F)と摂氏(0.0C)の比較である。\begin{kshell}>>> Float:F temp = 32.0F;>>> temp == 0.0C;false>>> temp === 0.0C;true\end{kshell}これらの演算子は、マッピング機能を応用して実現されている。詳しくは、「第\ref{chapter:semanticprogramming}章 セマンティックプログラミング」で述べる。\chapter{ステートメント}%A Konoha program is simply a collection of statements. This section describes the various statements in Konoha and explains their syntax. If you are familiar with C, C++, and Java, you will notice that the statements in Konoha are very similar, and you'll be able to skim this section quickly. プログラムは、ステートメントの集まりである。本章では、Konoha の基本的なステートメントとその文法を説明する。あらかじめ断っておきたいが、Konoha は C/C++, Java とステートメントレベルでの互換性を目標として設計されている。そのため、本章で紹介するステートメントは、経験豊富なプログラマには読み飛ばしてもほとんど問題のない章といえる。（頑張って書いた側に悲しい事実であるが、）なお、ステートメントの一般的な訳語は、「文」である。本来、ステートメントに統一すべきかも知れないが、{\sf if} ステートメントと呼ぶのは冗長な気がするので、広く慣習的に用いられている「{\sf if}文」的な呼称を用いている。\section{式によるステートメント}%The simplest kinds of statements in Konoha are expressions that change a program status. Assignment statements are one major category of expression statements. For example:もっとも簡単なステートメントは、プログラムの状態を変更する式(expression)である。代入式は、もっともよく使われるステートメントである。\begin{ksource}s = "Hello " + name;i *= 3;\end{ksource}%The increment and decrement operators, ++ and --, are related to assignment statements. インクリメント演算式(++)、デクリメント演算式(--)は、代入式の一種であるが、Konoha ではステートメントとして利用することができる。\begin{ksource}counter++;\end{ksource}%Function/method calls are another major category of expression statements. For example:関数/メソッドのコールも、もうひとつの代表的な式によるステートメントである。\begin{ksource}System.out.println("hello,world");Math.sin(0.5);\end{ksource}上記以外の任意の式もステートメントとして用いることができる。しかし、プログラムの状態を変更しない式は、コンパイラによって無視され、実際には評価されない。\begin{ksource}if(a == 1) print a;a + 1                       // 無視されるreturn a;\end{ksource}%Before proceeding next, recall that statements in Konoha are separated from each other with semicolons. It is a good idea to get in the habit of using semicolons everywhere.\section{ブロック}\index{block@block}% Konoha has a way to combine a number of statements into a single statement, or statement block. This is done simply by enclosing any number of statements with curly braces. ステートメントブロックは、0個以上のステートメントまとめてひとつのステートメントとして扱えるようにする。これは、任意のステートメントを中括弧 \verb|{ }|で囲むことで作ることができる。\begin{ksource}{   x = Math.PI;   a = Math.cos(x);   print a;}\end{ksource}ブロックを使うときは、インデントすると読みやすい。また、Konoha では、メソッド(関数)内同一スコープであるため、ブロックの中で宣言した変数はブロック外でも有効になる。%Note that although this statement block acts as a single statement, it does not necessary end with a semicolon. The elemental statements within the block end in semicolons, but the block itself does not.\section{変数の型宣言}\index{かたせんげん@型宣言}Konoha の変数は、静的に型付けされており、新しい変数を使うとき、型宣言が必要となる。C/C++やJavaと同様、型名 変数名の形式で、必要に応じて変数の初期値を与えられる。また同じ型であれば、複数の変数をひとつのステートメントで宣言できる。\begin{ksource}String s;                          // 初期値なしString t = "hello,world";          // 初期値ありString u, v = "ABC";               // 同じ型の複数の変数宣言\end{ksource}Java との大きな違いは、初期値の扱いである。Konoha は、@Nullable 修飾子（もしくは型名のあとに\verb|?|)追加しなかれば、全て NonNull 型となる。したがって、初期値の指定がない場合の初期値は、null ではなく、そのクラスのデフォルト値となる。\begin{kshell}>>> String s>>> s""\end{kshell}逆に、C\#風に\verb|?|を型名に付けるか、@Nullableアノテーションを用いれば、null を保持可能な変数となる。この場合の初期値は、null である。\begin{kshell}>>> String? t                      // Nullable>>> tnull\end{kshell}\subsection{{\sf var} 文*}{\sf var} 文は、JavaScript など一部のスクリプティング言語で採用されている変数宣言のための特別なステートメントである。Konoha では、静的に型付けして型宣言を行うため、{\sf var} 文では初期値から型推論を行い、静的な型付けを行っている。\begin{ksource}var i;                             // Any 型（型推論なし)var s = "hello,world";             // s は、String 型var x = Math.cos(0.75);            // x は、Float 型\end{ksource}注意：{\sf var} 文は省略可能である。始めての使用する変数への代入は、型推論による変数宣言とみなされる。\section{{\sf if/else} 文}\index{if@if文}%6.3	if%The if statement is the fundamental control statement that allows Konoha to execute statements conditionally. This statement has two forms. The first is:{\sf if} 文は、もっとも基本的な制御ステートメントである。与えられた条件式に応じて、続いて実行するステートメントの切り替えるときに使用する。{\sf if} 文には、2種類の形式がある。次は、簡単な形式である。\begin{quote}\verb|if| ($expr$) $stmt$\end{quote}%In this form, the expression is first evaluated. If the resulting value is true, then statement is executed. If expression is false, statement is not executed. For example:この形式では、条件式$expr$がまず評価される。その結果が、{\sf true}であれば、それに続くステートメント$stmt$が実行される。もし条件式の結果が{\sf false}であれば、ステートメント$stmt$は実行されない。\begin{kshell}>>> n = 4>>> if (n mod 2 == 0) print "even";even\end{kshell}%As mentioned in the previous section, you can always replace a single statement with a statement block.  {\sf if} 文に続くステートメントとして、ブロックを用いることもできる。ブロックを用いれば、0個以上のステートメントを順次実行することもできる。\begin{kshell}>>> if (n mod 2 == 0) {...    print "even";... }even\end{kshell}%The indention used in these examples is not mandatory. Using line breaks and indention as shown here makes the code easier to read and understand. %The second form of the if statement introduces an else clause that is executed when expression is false. Its syntax is:\subsection{{\sf else}節}\index{else@else節}{\sf if}文に続く{\sf else}節は、別のステートメントを与えるときに利用する。\begin{quote}\verb|if| ($expr$) $stmt1$ \verb|else| $stmt2$\end{quote}%In this form of the statement, expression is evaluated, and if it is true, statement1 is executed; otherwise, statement2 is executed. For example:この形式の{\sf if}文では、まず条件式$expr$が評価され、もしそれが{\sf true}であればステートメント$stmt1$が実行され、そうでなければ$stmt2$が実行される。\begin{kshell}>>> n = 3>>> if (n mod 2 == 0) {...    print "even";... } else {...    print "odd";... }odd\end{kshell}\subsection{{\sf else if}}{\sf if/else}文を使うことで、2つのステートメントを条件に応じてディスパッチすることができた。更に、{\sf if/else}文を組み合わせ、あたかも {\sf else if} 文のように用いると、3つ以上の条件分岐をすっきりと書くことができる。\begin{ksource}if(n == 1) {  // n が1のとき}else if(n == 2) {  // n が1のとき}else if(n == 3) {  // n が1のとき}else {   // それ以外のとき}\end{ksource}{\sf else if}文は、特別なステートメントではなく、ふつうの{\sf if/else}文の組み合わせたに過ぎない。条件式は、\verb|(n == 1)|から順番に評価されていくため、後に続く条件判定の処理ほど遅くなる。\section{{\sf switch} 文**}\index{switch@switch文}%6.4	switch%The switch statement is not supported in the version 0.5 of Konoha.{\sf switch} 文は、多重ディスパッチを行うための専用のステートメントである。{ｴif/else}文よりもすっきりと条件分岐をかくことができる。文法は、C/C++ や Java と同様に次のとおりである。\begin{quote}\verb|switch| ($expr$) ｴverb|{| \\\verb|   case | $c_1$ \verb| : | $stmt_1$; \\\verb|   case | $c_2$ \verb| : | $stmt_2$; \\\verb|   ... |\\\verb|   case | $c_n$ \verb| : | $stmt_n$; \\\verb|   default :|  $stmt$; \\ｴverb|}|\end{quote}\section{{\sf while/do-while} 文}\index{while@while文}% The while loops repeatedly execute a statement block while its condition expression is true.%6.5	while%The while statement is the basic statement that allows Konoha to perform repetitive actions. It has the following syntax:{\sf while}文は、あるステートメントを繰り返し実行させる基本的なステートメントである。ループの制御構造とも呼ばれる。その文法は次のとおりである。\begin{quote}\verb|while| ($expr$) $stmt$\end{quote}%The while loops repeatedly execute a statement block while its condition expression is true.{\sf while} 文は、条件式$expr$が{\sf true}の間、続くステートメント$stmt$を繰り返す。次は、変数 a が0より大きい間、繰り返し実行される。\begin{kshell}a = 1;while(a > 0) {	a = Int.random(10);	print a;}\end{kshell}%The do-while loops differ in that the condition is tested after the statement block has been executed. Konohaでは、ループを実現するステートメントとして、{\sf do-while}文のバリエーションがある。\verb|do| $stmt$ \verb|while| ($expr$);{\sf do-while} ループは、先にステートメント$stmt$を一度実行したあと、条件$expr$によって繰り返しの有無を定を行う。{\sf while}と{\sf do-while}の違いは、{\sf while}が条件に次第では1回もステートメントが実行されないのに対し、{\sf do-while}の方は必ず１回は実行される点である。\begin{kshell}do {	a = Int.random(10);	print a;}while(a > 0);\end{kshell}\section{{\sf for} 文}%The for loops are a conventional alternative to the while loops with special clauses for initialization and iteration of a loop variable.{\sf for} 文は、変数の初期化とその値の増減を繰り返すときに便利なwhile 文の置き換えである。実際、次のソースコードは、\begin{kshell}for(i = 0; i < 10; i++) {	print i;}\end{kshell}以下の{\sf while}文と全く同じである。\begin{kshell}i = 0;while(i < 10) {	print i;	i++;}\end{kshell}\section{{\sf break} 文 と {\sf continue} 文}%The break statement ends the statement block of a while loop, for loop, or foreach loop:Konoha は、{\sf break}と{\sf continue}という2種類のループ制御のステートメントをもっている。{\sf break} 文を使うと、現在繰り返しているループ構造のブロックから抜け出すことができる。\begin{kshell}while(true) {	dice  = Int.random(6) + 1;	dice2 = Int.random(6) + 1;	print dice, dice2;	if(dice == dice2) break;    // ゾロ目の場合、終了}\end{kshell}% The continue statement skips the remaining statements in the loop and restart the loop with the next iteration status. {\sf continue} 文を使うと、現在繰り返しているループ構造のブロックの残りのパートをスキップする。\begin{kshell}for(i = 0; i < 10; i++) {	if(i % 2 == 0) continue;	print i, ...;}\end{kshell}\subsubsection{多重ループからの{\sf break}と{\sf continue}}ループ構造は、{\sf while}文や{\sf for/foreach}文を組み合わせて、多重ループを作ることができる。多重ループの中では、どのループを対象として、{\sf break}したり、{\sf continue} するのか問題となります。Konoha では、ループにラベルをつけることで、どのループからの{\sf break}/{\sf continue}なのか明示的に示すことができる。また、ラベルを省略すれば、今まで通り暗示的に最も内側のループが対象となる。\begin{kshell}OUTER: for(y = 0; y < 8; y++) {	INNER: 	for(x = 0; x < 8; x++) {		if (x == y) continue OUTER; /* 外側 */		if (x < y) break; /* 内側 */		print x, y;	}}\end{kshell}\section{{\sf for/in} 文}%The foreach statement iterates over each element in an Iterator object. {\sf foreach} は、イテレータ内の各オブジェクトに対して繰り返し処理を行う専用のループ構造である。多くの場合、{\sf for} 文よりもわかりやすく、高速な処理が可能になります。\begin{kshell}foreach(String line from new InputStream("file.txt")) {	print line;}\end{kshell}All of objects in Konoha are convertible to an Iterator object. See the upcoming "Foreach and Iteration " section for detailed information. Konoha は、{\sf foreach} 文を大きく拡張してあります。詳しくは、「第\ref{section:foreach}節 {\sf foreach}とクエリー処理」を参照してください。% All of objects in Konoha are convertible to an Iterator object. See the upcoming "Foreach and Iteration " section for detailed information. %\section{{\sf try-catch-finally}}%Konoha は、モダンな例外処理機構を備えています。\begin{comment}\begin{kshell}try {	in = new InputStream("/dev/null");	line = in.readLine();}catch(IO!! ex) {	print ex;}catch(Security!! ex) {	print ex;}finally {	in.close();}\end{kshell}\end{comment}