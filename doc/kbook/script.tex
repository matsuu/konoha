\chapter{スクリプトと名前空間}スクリプトは、Konoha のプログラムの単位である。プログラムは、スクリプトファイルに記述され、それがロードされたのち、コンパイルされたスクリプトは{\sf Script} クラスと名前空間 {\sf NameSpace} クラスによって管理される。本章では、{\sf Script}と{\sf NameSpace}クラスを紹介しながら、Konoha 特有のスクリプティング機能も紹介する。\section{名前空間 NameSpace}Konohaは、大規模なソフトウェア開発を想定しているわけでないが、シンプルかつ十分な名前空間の機構を備えている。全てのスクリプトは、最初、デフォルトの名前空間 \verb|main| をもっている。現在の名前空間は、システム変数\verb|__ns__|で確認することができる。 \begin{kshell}>>> __ns__"main"\end{kshell}システム変数\verb|__ns__|は、{\sf NameSpace}型で、現在の名前空間のオブジェクトを返す。通常、名前空間は、{\sf using}文などを通して自動的に一貫性をもって管理されている。\subsection{クラス識別子とニックネーム*}クラスは、class 文で宣言されたとき、その名前空間を前置名にして宣言される。実は、これがKonoha システム内での正式なクラス識別子となる。\begin{kshell}>>> class C ;>>> C                          // 正式なクラス識別子main.C\end{kshell}Konoha は、クラス識別子を型の名前として仕様できない。あくまでもクラス名を用いる。それぞれの名前空間は、クラス名とクラス識別子を結びつけたニックネーム表をもっている。\begin{kshell}>>> class C>>> %dump(__ns__)             // ニックネーム表の確認Script    main.ScriptC         main.C\end{kshell}\subsection{パッケージとクラス名*}パッケージは、パッケージ名を名前空間としてもったスクリプトである。例えば、{\sf math} パッケージ内の {\sf Math}クラスは、クラス識別子は\verb|math.Math|となる。konoha パッケージ外の名前空間に属すクラス識別子は、自動的にニックネーム表に登録されない。そこで、明示的にニックネーム表に登録する必要がある。{\sf using}文は、もしパッケージが未ロードであればパッケージのロードを行ったのち、指定されたクラスをニックネーム表に登録するステートメントである。\begin{kshell}>>> using math.Math;>>> Mathmath.Math>>> %dump(__ns__)Script    main.ScriptC         main.CMath      math.Math\end{kshell}もし指定したパッケージ内にニックネーム表と同じクラス名が存在する場合は、既存の名前を優先する。強制的に新しい名前を用いたい場合は、\verb|@Override|を使うこともできる。ただし、予期せぬ混乱をまねく可能性があるのであまりおすすめできない。もし、パッケージ内の全てのクラスをロードしたい場合は、ワイルドカードを用いることができる。パッケージ内に多くのクラスが存在するときは、こちらを使うと便利である。\begin{kshell}>>> using math.*;\end{kshell}また、クラス名を省略すると、パッケージのみのロード、もしくは強制的な再ロードを意味する。このときは、ニックネーム表は更新されない。\begin{kshell}>>> using math;\end{kshell}\section{スクリプトクラス {\sf Script}}Konoha は、スクリプトファイルを読み始める前に、新しい{\sf Script}クラスを生成する。このとき、名前空間ごとに異なるクラスを生成するため、名前空間が\verb|main|であれば、クラス識別子は \verb|main.Script|のように生成される。また、新しく生成された\verb|main.Script|は、Konohaが標準的に提供する基本パッケージ\verb|konoha.Script|の性質を継承している。{\sf Script}クラスとスクリプトファイルは、ちょうど \verb|class Script|宣言のブロック中にスクリプトファイルが置かれたものと考えるとわかりやすい。グローバル（に見えた）変数は、実は{\sf Script}クラスのフィールド変数に相当し、関数も{\sf Script}のメソッドとなる。Konoha言語では、それぞれ{\bf スクリプト変数}、{\bf スクリプト関数}と呼ばれる。{\it class Script}\begin{kshell}{// スクリプトファイル の始まり// スクリプトファイル の終わり}\end{kshell}スクリプトファイルが、通常のクラス宣言と異なる点は、直接、ステートメントを記述できる点である。（これは、{\bf スクリプトステートメント}と呼ばれる。) 例えば、次はスクリプトステートメントの例である。\begin{kshell}for(i = 0; i < 10; i++) print i;\end{kshell}スクリプトステートメントは、無名関数によってラップされて実行される。つまり、上のスクリプトステートメントは、次の\verb|lambda()|関数定義と呼び出しと同義である。\begin{kshell}Any lambda() {	for(i = 0; i < 10; i++) print i;}lambda();\end{kshell}注意：次節で述べるとおり、変数 \verb|i|は、\verb|lambda()|関数内のローカル変数となるため、注意が必要である。\section{スクリプト変数}スクリプト変数は、{\sf Script}クラスのフィールド変数である。グローバル変数のように振る舞うが、実は名前空間が違えば、その名前空間に固有の{\sf Script}オブジェクトを通してアクセスしているため、参照されることはない。つまり、スクリプト変数のスコープは名前空間によって分離されている。\begin{kshell}// スクリプト変数card = new int[54];              // スクリプト変数\end{kshell}{\sf Script}クラスは、特別な\verb|@Singleton|クラスとして導入されている。インスタンスの数がひとつに限定されるため、実行中であっても一貫性を乱すことなくフィールド変数を増やすことができる。その上限数は、おおよそ128変数くらいである。上限数がはっきりしない理由は、Konohaの最適化オプションの状態で、UNBOXFIELDが採用された場合、{\sf int}と{\sf float}はそれぞれ2変数分の領域を消費することがあるためである。どちらにしても、通常のプログラミングにおいてスクリプト変数を使い切ることはないし、そのようなスクリプトは（メンテナンス性がないため）書いてはいけない。ちょっとしたテクニックであるが、スクリプト中で一次的に利用する変数は、ブロックステートメントなどを利用してローカル変数として扱うこともできる。また、スクリプト変数が不足するようなプログラムはメンテナンス不能になるため、書いてはいけない。\begin{kshell}card = new int[54];              // スクリプト変数{	int i;  　　　　　　　　　　 // ローカル変数	for(i = 0; i < |card|; i++) {		card[i] = Int.random(i);	}}\end{kshell}\subsection{変数スコープ}Konoha は、単純化された３つの変数スコープをもつ。変数名は、まずローカル変数を検索し、続いてフィールド変数、最後にスクリプト変数を検索する。明示的に、フィールド変数やスクリプト変数を参照したい場合は、変数名の前に\verb|_|, \verb|__|をそれぞれ付ける。もしくは、フィールド変数、スクリプト変数を宣言するときにあらかじめ付けておいても構わない。\begin{kshell}>>> String s = "script";         // スクリプト変数>>> class Person {>>> String s = "field";　        // フィールド変数... 	void test() {...			String s = "local";  // ローカル変数...			print s, _s, __s;...		}...	}>>> t = new T();>>> t.test()s="local", _s="field", __s="script"\end{kshell}\subsection{定数の定義}スクリプトの重要な役割は、定数の定義である。Konohaでは、名前ルールによって、グローバル定数、ローカル定数、クラス定数がある。\begin{kshell}GLOBAL_ = LOCAL = Math.PI_2 = \end{kshell}%\section{スクリプト関数}%\section{スクリプトファイル}%\section{main()関数}