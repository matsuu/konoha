\chapter{関数}Konohaにおける関数は、{\sf Script} クラスのメソッドである。しかし、オブジェクト指向プログラミングのクラス概念を導入しなくても利用できる伝統的なモジュール化手法であり、手続き型言語の呼称を好んで関数、もしくはスクリプト関数と呼んでいる。\section{関数}\begin{quote}\begin{jverbatim}\end{jverbatim}\end{quote}\subsection{関数内同一スコープ}Konoha は、C/C++ や Javaとは大きく異なり、ブロックレベルの変数スコープをサポートしていない。関数内で宣言された全ての変数は、どこで宣言されても関数内で利用できる。ただし、変数宣言より先に変数を使うことはできない。% Unlike C, C++, and Java, Konoha does not have block-level scope. All variables declared in a function, no matter where they are declared, are defined throughout the function. In the following code, the variables i, j, and k all have the same scope; all three are defined throughout the body of the function.例えば、次のコードにおいて、変数 \verb|k|, \verb|j| は、スコープ内として扱われる。\begin{quote}\begin{jverbatim}void test(int n) {	int i = 0;	if(n > 10) {		int j = 0;		for(int k = 0; k < n; k++) {			print k;		}		print k;                         // スコープ外ではない	}	print j;                             // スコープ外ではない}\end{jverbatim}\end{quote}次のような例外処理のコードを書くときも都合がよい。\begin{quote}\begin{jverbatim}try {	InputStream in = new InputStream("file.txt");	for(String line from in) {		print line;	}}catch(IO!! e) {	print format("Error at %d", in.line);}finally {	in.close();}\end{jverbatim}\end{quote}また、Konoha は同一スコープ内であっても同じ型であれば、何回、型宣言を行ってもエラーとならない。そのため、コピー＆ペーストする場合も支障とならない。\section{ビルトイン関数}Konoha は、コンパイラが実行プログラミング言語構造と密接に関連した機能を関数形式で利用できるようになっている。これらは、関数の形式で利用できるようにビルトイン関数として提供している。\subsection{スタティックな型付け typeof()}ビルトイン関数 \verb|typeof(expr)| は、プログラム中で、与えられた式exprのスタティックな型を調べるビルトイン関数である。\begin{quote}\begin{jverbatim}>>> a = 1>>> typeof(a)Int>>> typeof("hello,world")String\end{jverbatim}\end{quote}これに対し、\verb|(expr).class| は、実行時のexprがもつクラス（型）を調べるメソッドである。typeof(expr)とinstanceof の関係が成り立つが、必ずしも一致するとは限らない。また、型をもたないトークン（例えば予約語など)を評価した場合、{\sf void}型が返される。\verb|typeof()| 関数の評価は、コンパイラの型検査時に行われる。つまり、あまりおすすめではないが、次のように型名の代わりに型宣言にも利用できる。\begin{quote}\begin{jverbatim}int f(int n) {	typeof(n) m = n + 1;	return m;}\end{jverbatim}\end{quote}\subsection{識別子の存在 defined()}ビルトイン関数 \verb|defined(name)| は、識別子 nameが定義されているかどうか調べる関数である。\begin{quote}\begin{jverbatim}>>> defined(Class)true>>> defined(System.LINUX)false>>> defined(a)false>>> a = 1>>> defined(a)true\end{jverbatim}\end{quote}\verb|defined()| 関数の評価も、コンパイラの型検査時に行われ、必ず論理値 {\sf true} もしくは{\sf false} に置き換えられている。\begin{quote}\begin{jverbatim}if(!defined(System.LINUX)) {	print os.uname;}\end{jverbatim}\end{quote}\subsection{デフォルト値をえる default()}デフォルト関数\verb|default(expr)| は、プログラム中で、与えられた式exprの型からそのデフォルト値をえる関数である。\begin{quote}\begin{jverbatim}>>> default(String)"">>> default(%s(1))"">>> default(Script)                // Script は実行依存main.Script\end{jverbatim}\end{quote}多くのデフォルト値は、スタティックに解決される。しかし、いくつかのクラスは、実行コンテクストに依存する。そのため、デフォルト値も存在する。そのため、\verb|default()|は\verb|typeof()|と同様にスタティックに型まで決定し、一部のデフォルト値は実行時に得ている。\subsection{デリゲートの生成 delegate()}ビルトイン関数 \verb|delegate()| は、デリゲートクロージャを生成する関数である。デリゲートの詳細は、「第\ref{sec:delegate}節 デリゲート」で述べる。デリゲート\verb|delegate(o, m)|は、閉包するオブジェクト\verb|o|と呼び出すメソッド名\verb|g|をセットにしてクロージャを生成する。\begin{quote}\begin{jverbatim}>>> String s = "name";>>> f = delegate(s, split);>>> f()                             // s.split() が呼ばれる["n", "a", "m", "e"]\end{jverbatim}\end{quote}もしくは、\verb|delegate(f)|のように関数名\verb|f|のみを引数として与え、クロージャを生成することもできる。\begin{quote}\begin{jverbatim}>>> g = delegate(fibo);>>> g(10)                           // Script.fibo(10) が呼ばれる55\end{jverbatim}\end{quote}\section{クロージャ}\section{デリゲートクロージャ}\section{無名関数}\chapter{クラスとオブジェクト}%The object-oriented programming features in Konoha are mostly inspired by Java, nominal class and single-inheritance. Here is a running example in this section.Konohaのオブジェクト指向プログラミングは、名前ベースのクラス(nominal class)、単一継承(single-inheritance)など、主にJava 言語のそれから影響を受けている。\section{class 宣言}新しいクラスは、class 文を用いて宣言することで定義できる。class 文の最も簡単なシンタックスは、次のとおりである。クラス継承を含めたシンタックスは、「第\ref{sec:classinheritance}節 クラス継承」で扱う。\begin{quote}\verb|class| $ClassName$ \verb|{| \\  $ClassMembers$ // クラスのメンバー \\\verb|}| \\\end{quote}クラスのメンバーには、フィールド変数(field variable)、メソッド(method)、コンストラクタ(constructor)が含まれる。\begin{itemize}\item {\bf フィールド変数} は、SmallTalk ではインスタンス変数、C++ではメンバ変数、Java ではフィールドと呼ばれるが、オブジェクトの内部状態を表す変数である。Java ではフィールド変数と呼ばないのが正しいらしいのだが、Konoha では変数の種類はそれがどこにあるかを区別しているため、「フィールド変数」と呼ばさせて頂いている。\item {\bf メソッド} は、SmallTalkではメッセージ、C++ではメンバ関数とも呼ばれるが、オブジェクトの内部状態を操作する手続きである。関数と同様に引数（パラメータと呼ぶ）を受けて処理を行い戻り値で結果を返す。Konoha では、オブジェクトへの操作が明確なときはメソッド/パラメータ、そうでないときは旧来風に関数/引数の呼称を用いている。\item {\bf コンストラクタ} は、新しくオブジェクトを生成するときに\verb|new|演算子を用いて呼び出される特別なメソッドである。なお、Konoha は、ガベージコレクションの機構を備えているため、明示的なオブジェクト破壊を行う必要なない。\end{itemize}さて、次はKonoha におけるクラス定義の例である。\begin{quote}\begin{jverbatim}class Person {	String _name;                  // フィールド変数	int age;	                               // コンストラクタ	Person(String name, int age) {		_name = name;		_age = age;	}	String getName () { 	       // メソッド		return _name; 	}}\end{jverbatim}\end{quote}Konoha は、スクリプティング言語の柔軟さを提供するため、メソッドやコンストラクタをクラスに追加することができる。しかし、フィールド変数のみは、{\sf class}文で宣言しなければならない。\subsection{クラスアノテーション*}アノテーションを用いることで、クラスにいくつかの特性を与えることができる。\begin{quote}\begin{jverbatim}アノテーション	      説明@Private              名前空間からみることはできない。@Final                これ以上、継承することはできない@Interface            インターフェースとして利用することが可能@Release              デバッグの完了したクラス\end{jverbatim}\end{quote}\section{コンストラクタ}\section{フィールド変数}%The names of field variables should start with an underscore character. If you forget this rule (like age), the complier automatically adds _ to its name;フィールド変数は、アンダースコア(\verb|_|)で始まる変数名をもつ。これは、Java プログラマがよく使っているローカル変数とフィールドを区別する慣習に由来するが、フィールド変数宣言のとき、アンダースコアを付け忘れなくても、コンパイラは自動的にフィールド変数にアンダースコアを付加する。\begin{quote}\begin{jverbatim}class Person {	String _name;  	int age;       // もし _ を付けなくても	Person(String name, int age) {		_name = name;		_age = age;  // _ は、フィールド変数へのアクセスに必要	}}\end{jverbatim}\end{quote}%More importantly, the declaration of non-underscored field variables is shorthand for the automatic generation of its getter/setter. The compiler generates: 重要な留意点は、フィールド変数宣言のとき、アンダースコアを付けないことは、自動的な getter/setter メソッドの生成を意味する。これは、次節で述べるとおり、フィールド変数の public 宣言に等しい。\begin{quote}\begin{jverbatim}class Person {	...	int age;	int getAge() { return _age;}           // 自動生成	void setAge(int age) { _age = age; }   // 自動生成}\end{jverbatim}\end{quote}%\subsection{Field accessors}\subsection{フィールドアクセサ}%In Konoha, all of field variables are private. You will have to access fields through getter/setter methods. Konohaは、全てのフィールド変数はいわゆる {\sf private} である。オブジェクト外部から直接参照はできず、全て getter/setter メソッドを用いて行う。\begin{quote}\begin{jverbatim}>>> p = new Person("naruto", 17);>>> p.getName();"naruto">>> p.setAge(18);>>> p.getAge();18\end{jverbatim}\end{quote}% This looks cumbersome. Konoha has the dot(.) operator for the shorthand of getter/setter. Using this, the above is same as:フィールドへのアクセスに getter/setter メソッドを多用するのは、Java が産み出したトレンドである。しかし、これは何かと不便に感じる人も多い。そこで、Konohaは、フィールドアクセサ(\verb|.|演算子)を、getter/setter を呼び出すための省略形(シンタックスシュガー）として再利用している。\begin{quote}\begin{jverbatim}>>> p = new Person("naruto", 17);>>> p.name;                   // 実は p.getName()"naruto">>> p.age = 18;               // 実は p.setAge(18)>>> p.age;18\end{jverbatim}\end{quote}今までどおり、フィールドアクセスをしているように見えて、実は全てgetter/setter メソッドによってふるまいを変更することができる。\subsection{バーチャルフィールド}バーチャルフィールドとは、フィールド変数の実体がなくても、getter/setter を通して、あたかもフィールドが存在するようにふるまうことである。\begin{quote}\begin{jverbatim}class Person {	...	String name;	String getFirstName() { 		return _name.split(" ")[0];	}}>>> p = new Person("naruto uzumaki", 17);>>> p.name                    // 実は p.getName()"naruto uzumaki">>> p.firstName               // 実は p.getFirstName()"naruto"\end{jverbatim}\end{quote}Konoha では、そのオブジェクトのクラス{\sf Class}インタフェースを通して、フィールド変数、（バーチャル）フィールドのリストを得ることができる。\begin{quote}\begin{jverbatim}>>> p = new Person("naruto", 17);>>> p.class.fiedls("variable")["_name", "_age"]>>> p.class.fields("getter")["name", "age", "firstName", "lastName"]>>> p.class.fields("setter") ["name", "age"]\end{jverbatim}\end{quote}\subsection{this 参照}キーワード\verb|this|は、自オブジェクト参照への参照である。\verb|this|を用いたフィールドアクセサを用いると、フィールド変数を直接参照する代わりに、getter/setter を経由してアクセスすることになる。\begin{quote}\begin{jverbatim}	...	int age;	boolean isDrinkable() {		return (this.age => 20);	}\end{jverbatim}\end{quote}フィールドアクセサによる特別な結果を期待する場合でもない限り、\verb|_age|で直接フィールド変数を参照した方が高速である。次のように、getter/setter メソッド内でthis参照を用いると、予期しない依存関係から無限ループに陥る危険性もある。\begin{quote}\begin{jverbatim}	int _age;                        // やってはいけない	int getAge() { return this.age;} 	void setAge(int age) { this.age = age; } \end{jverbatim}\end{quote}Konoha コンパイラは、getter/setter 内では、this 参照を使うとエラーになる。\section{メソッド}メソッドは、オブジェクトに対してメッセージを送受信する手段である。0個以上のパラメータを受け取り、0もしくは1つの戻り値を返すことができる。次の \verb|isChild()|は、0個のパラメータ、Boolean 型の戻り値をもったメソッドの例である。\begin{quote}\begin{jverbatim}class Person {	String name;	int age;    ...	boolean isChild () {    	return (_age < 21);  	}}\end{jverbatim}\end{quote}\subsection{抽象メソッド}抽象メソッドは、メソッドのインターフェースのみ定義され、実装パートが定義されていないメソッドである。Konohaでは、メソッドにつづくブロックが存在しなければ、抽象メソッドと解釈される。また、メソッドのコンパイルに失敗したとき、自動的に抽象メソッドとして扱われる。\begin{quote}\begin{jverbatim}class Person {	String name;	int age;    ...	boolean hasFriend();           // 抽象メソッド}\end{jverbatim}\end{quote}抽象メソッドの本来の用途は、抽象クラスやインターフェースなど、クラス設計においてポリモーフィズムを実現する手段としての利用である。厳密なスタティック言語では、全ての抽象クラスが実装されていない限り、クラスのインスタンス化はできない。しかし、Konoha は、抽象メソッドが含まれているクラスであっても、インスタンス化を認めている。これは、ラピッドプロトタイピングにおいて、単純に抽象メソッドを未実装なメソッドとして扱うためである。抽象メソッドを実行すると、実行時例外となる。\begin{quote}\begin{jverbatim}>>> p = new Person("naruto", 17);>>> p.hasFriend()AbstractMethod!!: Person.hasFriend()\end{jverbatim}\end{quote}我々は、実行前にスタティックな抽象メソッドを検査する機構を検討している。現在のところ、実行時に\verb|isAbstract()|によって検査する方法しかない。\begin{quote}\begin{jverbatim}>>> String.isAbstract()false>>> Person.isAbstarct()true\end{jverbatim}\end{quote}\subsection{引数の初期値}Konoha 言語は、メソッド多重定義(overloading) をサポートしていません。その代わり、いくつかの便利の代替機能を提供しています。代替機能のひとつとして、引数の初期値を設定することができます。\begin{quote}\begin{jverbatim}\end{jverbatim}\end{quote}void Person.say(String msg="hello") {  print msg;}パラメータの初期値は、\begin{quote}\begin{jverbatim}\end{jverbatim}\end{quote}>>> p.say("aloha");msg="aloha">>> p.say();　　// p.say(null) と同義msg="hello"\subsection{メソッド追加}Java 言語では、class 文の中でのみメソッドを定義することができました。Konoha では、動的言語の柔軟さを実現するため、既存のクラスに対して、スクリプト中どこでも新たなメソッドを追加定義することができます。次のPerso.isChild()関数は、class Person 内で定義されたisChild() と同じ定義になります。\begin{quote}\begin{jverbatim}boolean Person.isChild () {   return (_age < 21);}\end{jverbatim}\end{quote}メソッド追加は、これからインスタンス化されるオブジェクトのみでなく、（追加した時点で）既にインスタンス化されたオブジェクトにも影響が及びます。\begin{quote}\begin{jverbatim}>>> Person p = new Person("naruto", 17);>>> boolean Person.isChild () {...   return (_age < 21);... }>>> p.isChild()true\end{jverbatim}\end{quote}\subsection{メソッドの複数バージョン管理}Konoha 言語は、メソッドの複数バージョンを管理することができます。ただし、文法はまだ決まっていないので非公開です。\begin{quote}\begin{jverbatim}\end{jverbatim}\end{quote}\section{オペレータとメソッドの関係}Konohaでは、全てのオペレータはメソッドの別表現(syntax suger)に過ぎない。例えば、加算演算 \verb|x + y| は、次のように単純にメソッド\verb|opAdd()|に置き換えられて実行されている。\begin{quote}\begin{jverbatim}x + y                 // x.opAdd(y)\end{jverbatim}\end{quote}そこで、演算子と対応つけられた\verb|op| で始まるメソッドを定義すれば、オペレータの振る舞いを変更することも可能である。ただし、演算子の再定義は、Konohaでは推奨されていない。\begin{quote}\begin{tabular}{lll}\verb|x == y| & \verb|x.opEq(y)| & 等しいか？ \\\verb|x != y| & \verb|x.opNeq(y)| & 等しくないか？ \\\verb|x < y| & \verb|x.opLt(y)| & より小さいか？ \\\verb|x <= y| & \verb|x.opLte(y)| & 以下か？ \\\verb|x > y| & \verb|x.opEq(y)| & より大きいか？ \\\verb|x >= y| & \verb|x.opNeq(y)| & 以上か？ \\\verb|(T)x| & \verb|x.opCast(T)| & x の型Tへの変換 \\\verb|x as T| & \verb|x.opAs(T)| & x の型Tへの変換 \\\verb|x to? T| & \verb|x.opTo(T)| & 型Tへの変換可能か？ \\\verb|T(x, y)| & \verb|x.opMap(T, y)| & x の型Tへの拡張変換 \\\verb|x instanceof T| & \verb|x.opInstanceof(T)| & インスタンスか？ \\\verb|x isa? y| & \verb|x.opIsa(T)| & IS-A か？ \\\verb|x === y| & \verb|x.opIs(T)| & x と y は同義か？ \\\verb|x + y| & \verb|x.opAdd(y)| & 加算 \\\verb|x - y| & \verb|x.opSub(y)| & 減算 \\\verb|x * y| & \verb|x.opMul(y)| & 乗算 \\\verb|x / y| & \verb|x.opDiv(y)| & 除算 \\\verb|x mod y| & \verb|x.opMod(y)| & 余り \\\verb|~x| & \verb|x.opLnot(y)| & ビット反転 \\\verb|x & y| & \verb|x.opLand(y)| & 論理積 \\\verb/x | y/ & \verb|x.opLor(y)| & 論理和 \\\verb|x ^ y| & \verb|x.opXor(y)| & 排他論理和(XOR) \\\verb|x << y| & \verb|x.opLshift(y)| & 左シフト \\\verb|x >> y| & \verb|x.opRshift(y)| & 右シフト \\\verb/|x|/ & \verb|x.getSize()| & シーケンスのサイズ \\\verb|x[n]| & \verb|x.get(n)| & n番目の値 \\\verb|x[n] = y| & \verb|x.set(n)| & n番目に値をセットする \\\verb|x[] = y| & \verb|x.setAll(n)| & 全部に値をセットする \\\verb/y in? x/ & \verb|x.opHas(y)| & 含まれているか？ \\\verb|x[s..e]| & \verb|x.opSubsete(s,e)| & sからeまでの部分 \\\verb|x[s..<e]| & \verb|x.opSubset(s,e)| & sからeまでの部分(eは含まない) \\\verb|x[s..+n]| & \verb|x.opOffset(s,n)| & sからn個の部分 \\\verb|x << y| & \verb|x.opLshift(y)| & x へのyの追加 \\\verb|x and y| & x かつ y が真のとき \\\verb|x or y| & x または y が真のとき \\\verb|not x| & x が真でないとき \\\verb|x ? y : z| &  xが真のときy、そうでなければz \\\verb|x ?? y| & xがnullのとき y \\\verb/x++/ & \verb|x = x.opNext()| & 次へ \\\verb/++x/ & \verb|x = x.opNext()| & 次へ \\\verb/x--/ & \verb|x = x.opPerv()| & 前へ \\\verb/--x/ & \verb|x = x.opPerv()| & 前へ \\\end{tabular}\end{quote}\section{フォーマッタとマッパー}\subsection{フォーマッタメソッド}You can define or add new formatters as methods, since formatters are a specialized method with the following signature.\begin{quote}\begin{jverbatim}void Object.%fmt(OutputStream w, String fmt) ;\end{jverbatim}\end{quote}Formatting is designed to output data to OutputStream. \begin{quote}\begin{jverbatim}void Person.%xml(OutputStream w, String fmt) {	w << "<person name='%s{0}'/>" %% _name << EOL;}\end{jverbatim}\end{quote}\begin{quote}\begin{jverbatim}>>> p = new Person("naruto", 17);>>> %xml(p)<person name='naruto'/>\end{jverbatim}\end{quote}\subsection{マッパーメソッド}\chapter{クラス階層と抽象化}